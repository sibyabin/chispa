{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"chispa chispa provides fast PySpark test helper methods that output descriptive error messages. This library makes it easy to write high quality PySpark code. Fun fact: \"chispa\" means Spark in Spanish ;) Installation Install the latest version with pip install chispa . If you use Poetry, add this library as a development dependency with poetry add chispa -G dev . Column equality Suppose you have a function that removes the non-word characters in a string. def remove_non_word_characters(col): return F.regexp_replace(col, \"[^\\\\w\\\\s]+\", \"\") Create a SparkSession so you can create DataFrames. from pyspark.sql import SparkSession spark = (SparkSession.builder .master(\"local\") .appName(\"chispa\") .getOrCreate()) Create a DataFrame with a column that contains strings with non-word characters, run the remove_non_word_characters function, and check that all these characters are removed with the chispa assert_column_equality method. import pytest from chispa.column_comparer import assert_column_equality import pyspark.sql.functions as F def test_remove_non_word_characters_short(): data = [ (\"jo&&se\", \"jose\"), (\"**li**\", \"li\"), (\"#::luisa\", \"luisa\"), (None, None) ] df = (spark.createDataFrame(data, [\"name\", \"expected_name\"]) .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\")))) assert_column_equality(df, \"clean_name\", \"expected_name\") Let's write another test that'll fail to see how the descriptive error message lets you easily debug the underlying issue. Here's the failing test: def test_remove_non_word_characters_nice_error(): data = [ (\"matt7\", \"matt\"), (\"bill&\", \"bill\"), (\"isabela*\", \"isabela\"), (None, None) ] df = (spark.createDataFrame(data, [\"name\", \"expected_name\"]) .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\")))) assert_column_equality(df, \"clean_name\", \"expected_name\") Here's the nicely formatted error message: You can see the matt7 / matt row of data is what's causing the error (note it's highlighted in red). The other rows are colored blue because they're equal. DataFrame equality We can also test the remove_non_word_characters method by creating two DataFrames and verifying that they're equal. Creating two DataFrames is slower and requires more code, but comparing entire DataFrames is necessary for some tests. from chispa.dataframe_comparer import * def test_remove_non_word_characters_long(): source_data = [ (\"jo&&se\",), (\"**li**\",), (\"#::luisa\",), (None,) ] source_df = spark.createDataFrame(source_data, [\"name\"]) actual_df = source_df.withColumn( \"clean_name\", remove_non_word_characters(F.col(\"name\")) ) expected_data = [ (\"jo&&se\", \"jose\"), (\"**li**\", \"li\"), (\"#::luisa\", \"luisa\"), (None, None) ] expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"]) assert_df_equality(actual_df, expected_df) Let's write another test that'll return an error, so you can see the descriptive error message. def test_remove_non_word_characters_long_error(): source_data = [ (\"matt7\",), (\"bill&\",), (\"isabela*\",), (None,) ] source_df = spark.createDataFrame(source_data, [\"name\"]) actual_df = source_df.withColumn( \"clean_name\", remove_non_word_characters(F.col(\"name\")) ) expected_data = [ (\"matt7\", \"matt\"), (\"bill&\", \"bill\"), (\"isabela*\", \"isabela\"), (None, None) ] expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"]) assert_df_equality(actual_df, expected_df) Here's the nicely formatted error message: Ignore row order You can easily compare DataFrames, ignoring the order of the rows. The content of the DataFrames is usually what matters, not the order of the rows. Here are the contents of df1 : +--------+ |some_num| +--------+ | 1| | 2| | 3| +--------+ Here are the contents of df2 : +--------+ |some_num| +--------+ | 2| | 1| | 3| +--------+ Here's how to confirm df1 and df2 are equal when the row order is ignored. assert_df_equality(df1, df2, ignore_row_order=True) If you don't specify to ignore_row_order then the test will error out with this message: The rows aren't ordered by default because sorting slows down the function. Ignore column order This section explains how to compare DataFrames, ignoring the order of the columns. Suppose you have the following df1 : +----+----+ |num1|num2| +----+----+ | 1| 7| | 2| 8| | 3| 9| +----+----+ Here are the contents of df2 : +----+----+ |num2|num1| +----+----+ | 7| 1| | 8| 2| | 9| 3| +----+----+ Here's how to compare the equality of df1 and df2 , ignoring the column order: assert_df_equality(df1, df2, ignore_column_order=True) Here's the error message you'll see if you run assert_df_equality(df1, df2) , without ignoring the column order. Ignore nullability Each column in a schema has three properties: a name, data type, and nullable property. The column can accept null values if nullable is set to true. You'll sometimes want to ignore the nullable property when making DataFrame comparisons. Suppose you have the following df1 : +-----+---+ | name|age| +-----+---+ | juan| 7| |bruna| 8| +-----+---+ And this df2 : +-----+---+ | name|age| +-----+---+ | juan| 7| |bruna| 8| +-----+---+ You might be surprised to find that in this example, df1 and df2 are not equal and will error out with this message: Examine the code in this contrived example to better understand the error: def ignore_nullable_property(): s1 = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", IntegerType(), True)]) df1 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s1) s2 = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", IntegerType(), False)]) df2 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s2) assert_df_equality(df1, df2) You can ignore the nullable property when assessing equality by adding a flag: assert_df_equality(df1, df2, ignore_nullable=True) Elements contained within an ArrayType() also have a nullable property, in addition to the nullable property of the column schema. These are also ignored when passing ignore_nullable=True . Again, examine the following code to understand the error that ignore_nullable=True bypasses: def ignore_nullable_property_array(): s1 = StructType([ StructField(\"name\", StringType(), True), StructField(\"coords\", ArrayType(DoubleType(), True), True),]) df1 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s1) s2 = StructType([ StructField(\"name\", StringType(), True), StructField(\"coords\", ArrayType(DoubleType(), False), True),]) df2 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s2) assert_df_equality(df1, df2) Allow NaN equality Python has NaN (not a number) values and two NaN values are not considered equal by default. Create two NaN values, compare them, and confirm they're not considered equal by default. nan1 = float('nan') nan2 = float('nan') nan1 == nan2 # False pandas considers NaN values to be equal by default, but this library requires you to set a flag to consider two NaN values to be equal. assert_df_equality(df1, df2, allow_nan_equality=True) Customize formatting Available in chispa 0.10+ . You can specify custom formats for the printed error messages as follows: @dataclass class MyFormats: mismatched_rows = [\"light_yellow\"] matched_rows = [\"cyan\", \"bold\"] mismatched_cells = [\"purple\"] matched_cells = [\"blue\"] assert_basic_rows_equality(df1.collect(), df2.collect(), formats=MyFormats()) You can also define these formats in conftest.py and inject them via a fixture: @pytest.fixture() def my_formats(): return MyFormats() def test_shows_assert_basic_rows_equality(my_formats): ... assert_basic_rows_equality(df1.collect(), df2.collect(), formats=my_formats) Approximate column equality We can check if columns are approximately equal, which is especially useful for floating number comparisons. Here's a test that creates a DataFrame with two floating point columns and verifies that the columns are approximately equal. In this example, values are considered approximately equal if the difference is less than 0.1. def test_approx_col_equality_same(): data = [ (1.1, 1.1), (2.2, 2.15), (3.3, 3.37), (None, None) ] df = spark.createDataFrame(data, [\"num1\", \"num2\"]) assert_approx_column_equality(df, \"num1\", \"num2\", 0.1) Here's an example of a test with columns that are not approximately equal. def test_approx_col_equality_different(): data = [ (1.1, 1.1), (2.2, 2.15), (3.3, 5.0), (None, None) ] df = spark.createDataFrame(data, [\"num1\", \"num2\"]) assert_approx_column_equality(df, \"num1\", \"num2\", 0.1) This failing test will output a readable error message so the issue is easy to debug. Approximate DataFrame equality Let's create two DataFrames and confirm they're approximately equal. def test_approx_df_equality_same(): data1 = [ (1.1, \"a\"), (2.2, \"b\"), (3.3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1.05, \"a\"), (2.13, \"b\"), (3.3, \"c\"), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"letter\"]) assert_approx_df_equality(df1, df2, 0.1) The assert_approx_df_equality method is smart and will only perform approximate equality operations for floating point numbers in DataFrames. It'll perform regular equality for strings and other types. Let's perform an approximate equality comparison for two DataFrames that are not equal. def test_approx_df_equality_different(): data1 = [ (1.1, \"a\"), (2.2, \"b\"), (3.3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1.1, \"a\"), (5.0, \"b\"), (3.3, \"z\"), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"letter\"]) assert_approx_df_equality(df1, df2, 0.1) Here's the pretty error message that's outputted: Schema mismatch messages DataFrame equality messages peform schema comparisons before analyzing the actual content of the DataFrames. DataFrames that don't have the same schemas should error out as fast as possible. Let's compare a DataFrame that has a string column an integer column with a DataFrame that has two integer columns to observe the schema mismatch message. def test_schema_mismatch_message(): data1 = [ (1, \"a\"), (2, \"b\"), (3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1, 6), (2, 7), (3, 8), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"num2\"]) assert_df_equality(df1, df2) Here's the error message: Supported PySpark / Python versions chispa currently supports PySpark 2.4+ and Python 3.5+. Use chispa v0.8.2 if you're using an older Python version. PySpark 2 support will be dropped when chispa 1.x is released. Benchmarks TODO: Need to benchmark these methods vs. the spark-testing-base ones Vendored dependencies These dependencies are vendored: six PrettyTable The dependencies are vendored to save you from dependency hell. Developing chispa on your local machine You are encouraged to clone and/or fork this repo. This project uses Poetry for packaging and dependency management. Setup the virtual environment with poetry install Run the tests with poetry run pytest tests Studying the codebase is a great way to learn about PySpark! Contributing Anyone is encouraged to submit a pull request, open an issue, or submit a bug report. We're happy to promote folks to be library maintainers if they make good contributions.","title":"Chispa"},{"location":"#chispa","text":"chispa provides fast PySpark test helper methods that output descriptive error messages. This library makes it easy to write high quality PySpark code. Fun fact: \"chispa\" means Spark in Spanish ;)","title":"chispa"},{"location":"#installation","text":"Install the latest version with pip install chispa . If you use Poetry, add this library as a development dependency with poetry add chispa -G dev .","title":"Installation"},{"location":"#column-equality","text":"Suppose you have a function that removes the non-word characters in a string. def remove_non_word_characters(col): return F.regexp_replace(col, \"[^\\\\w\\\\s]+\", \"\") Create a SparkSession so you can create DataFrames. from pyspark.sql import SparkSession spark = (SparkSession.builder .master(\"local\") .appName(\"chispa\") .getOrCreate()) Create a DataFrame with a column that contains strings with non-word characters, run the remove_non_word_characters function, and check that all these characters are removed with the chispa assert_column_equality method. import pytest from chispa.column_comparer import assert_column_equality import pyspark.sql.functions as F def test_remove_non_word_characters_short(): data = [ (\"jo&&se\", \"jose\"), (\"**li**\", \"li\"), (\"#::luisa\", \"luisa\"), (None, None) ] df = (spark.createDataFrame(data, [\"name\", \"expected_name\"]) .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\")))) assert_column_equality(df, \"clean_name\", \"expected_name\") Let's write another test that'll fail to see how the descriptive error message lets you easily debug the underlying issue. Here's the failing test: def test_remove_non_word_characters_nice_error(): data = [ (\"matt7\", \"matt\"), (\"bill&\", \"bill\"), (\"isabela*\", \"isabela\"), (None, None) ] df = (spark.createDataFrame(data, [\"name\", \"expected_name\"]) .withColumn(\"clean_name\", remove_non_word_characters(F.col(\"name\")))) assert_column_equality(df, \"clean_name\", \"expected_name\") Here's the nicely formatted error message: You can see the matt7 / matt row of data is what's causing the error (note it's highlighted in red). The other rows are colored blue because they're equal.","title":"Column equality"},{"location":"#dataframe-equality","text":"We can also test the remove_non_word_characters method by creating two DataFrames and verifying that they're equal. Creating two DataFrames is slower and requires more code, but comparing entire DataFrames is necessary for some tests. from chispa.dataframe_comparer import * def test_remove_non_word_characters_long(): source_data = [ (\"jo&&se\",), (\"**li**\",), (\"#::luisa\",), (None,) ] source_df = spark.createDataFrame(source_data, [\"name\"]) actual_df = source_df.withColumn( \"clean_name\", remove_non_word_characters(F.col(\"name\")) ) expected_data = [ (\"jo&&se\", \"jose\"), (\"**li**\", \"li\"), (\"#::luisa\", \"luisa\"), (None, None) ] expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"]) assert_df_equality(actual_df, expected_df) Let's write another test that'll return an error, so you can see the descriptive error message. def test_remove_non_word_characters_long_error(): source_data = [ (\"matt7\",), (\"bill&\",), (\"isabela*\",), (None,) ] source_df = spark.createDataFrame(source_data, [\"name\"]) actual_df = source_df.withColumn( \"clean_name\", remove_non_word_characters(F.col(\"name\")) ) expected_data = [ (\"matt7\", \"matt\"), (\"bill&\", \"bill\"), (\"isabela*\", \"isabela\"), (None, None) ] expected_df = spark.createDataFrame(expected_data, [\"name\", \"clean_name\"]) assert_df_equality(actual_df, expected_df) Here's the nicely formatted error message:","title":"DataFrame equality"},{"location":"#ignore-row-order","text":"You can easily compare DataFrames, ignoring the order of the rows. The content of the DataFrames is usually what matters, not the order of the rows. Here are the contents of df1 : +--------+ |some_num| +--------+ | 1| | 2| | 3| +--------+ Here are the contents of df2 : +--------+ |some_num| +--------+ | 2| | 1| | 3| +--------+ Here's how to confirm df1 and df2 are equal when the row order is ignored. assert_df_equality(df1, df2, ignore_row_order=True) If you don't specify to ignore_row_order then the test will error out with this message: The rows aren't ordered by default because sorting slows down the function.","title":"Ignore row order"},{"location":"#ignore-column-order","text":"This section explains how to compare DataFrames, ignoring the order of the columns. Suppose you have the following df1 : +----+----+ |num1|num2| +----+----+ | 1| 7| | 2| 8| | 3| 9| +----+----+ Here are the contents of df2 : +----+----+ |num2|num1| +----+----+ | 7| 1| | 8| 2| | 9| 3| +----+----+ Here's how to compare the equality of df1 and df2 , ignoring the column order: assert_df_equality(df1, df2, ignore_column_order=True) Here's the error message you'll see if you run assert_df_equality(df1, df2) , without ignoring the column order.","title":"Ignore column order"},{"location":"#ignore-nullability","text":"Each column in a schema has three properties: a name, data type, and nullable property. The column can accept null values if nullable is set to true. You'll sometimes want to ignore the nullable property when making DataFrame comparisons. Suppose you have the following df1 : +-----+---+ | name|age| +-----+---+ | juan| 7| |bruna| 8| +-----+---+ And this df2 : +-----+---+ | name|age| +-----+---+ | juan| 7| |bruna| 8| +-----+---+ You might be surprised to find that in this example, df1 and df2 are not equal and will error out with this message: Examine the code in this contrived example to better understand the error: def ignore_nullable_property(): s1 = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", IntegerType(), True)]) df1 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s1) s2 = StructType([ StructField(\"name\", StringType(), True), StructField(\"age\", IntegerType(), False)]) df2 = spark.createDataFrame([(\"juan\", 7), (\"bruna\", 8)], s2) assert_df_equality(df1, df2) You can ignore the nullable property when assessing equality by adding a flag: assert_df_equality(df1, df2, ignore_nullable=True) Elements contained within an ArrayType() also have a nullable property, in addition to the nullable property of the column schema. These are also ignored when passing ignore_nullable=True . Again, examine the following code to understand the error that ignore_nullable=True bypasses: def ignore_nullable_property_array(): s1 = StructType([ StructField(\"name\", StringType(), True), StructField(\"coords\", ArrayType(DoubleType(), True), True),]) df1 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s1) s2 = StructType([ StructField(\"name\", StringType(), True), StructField(\"coords\", ArrayType(DoubleType(), False), True),]) df2 = spark.createDataFrame([(\"juan\", [1.42, 3.5]), (\"bruna\", [2.76, 3.2])], s2) assert_df_equality(df1, df2)","title":"Ignore nullability"},{"location":"#allow-nan-equality","text":"Python has NaN (not a number) values and two NaN values are not considered equal by default. Create two NaN values, compare them, and confirm they're not considered equal by default. nan1 = float('nan') nan2 = float('nan') nan1 == nan2 # False pandas considers NaN values to be equal by default, but this library requires you to set a flag to consider two NaN values to be equal. assert_df_equality(df1, df2, allow_nan_equality=True)","title":"Allow NaN equality"},{"location":"#customize-formatting","text":"Available in chispa 0.10+ . You can specify custom formats for the printed error messages as follows: @dataclass class MyFormats: mismatched_rows = [\"light_yellow\"] matched_rows = [\"cyan\", \"bold\"] mismatched_cells = [\"purple\"] matched_cells = [\"blue\"] assert_basic_rows_equality(df1.collect(), df2.collect(), formats=MyFormats()) You can also define these formats in conftest.py and inject them via a fixture: @pytest.fixture() def my_formats(): return MyFormats() def test_shows_assert_basic_rows_equality(my_formats): ... assert_basic_rows_equality(df1.collect(), df2.collect(), formats=my_formats)","title":"Customize formatting"},{"location":"#approximate-column-equality","text":"We can check if columns are approximately equal, which is especially useful for floating number comparisons. Here's a test that creates a DataFrame with two floating point columns and verifies that the columns are approximately equal. In this example, values are considered approximately equal if the difference is less than 0.1. def test_approx_col_equality_same(): data = [ (1.1, 1.1), (2.2, 2.15), (3.3, 3.37), (None, None) ] df = spark.createDataFrame(data, [\"num1\", \"num2\"]) assert_approx_column_equality(df, \"num1\", \"num2\", 0.1) Here's an example of a test with columns that are not approximately equal. def test_approx_col_equality_different(): data = [ (1.1, 1.1), (2.2, 2.15), (3.3, 5.0), (None, None) ] df = spark.createDataFrame(data, [\"num1\", \"num2\"]) assert_approx_column_equality(df, \"num1\", \"num2\", 0.1) This failing test will output a readable error message so the issue is easy to debug.","title":"Approximate column equality"},{"location":"#approximate-dataframe-equality","text":"Let's create two DataFrames and confirm they're approximately equal. def test_approx_df_equality_same(): data1 = [ (1.1, \"a\"), (2.2, \"b\"), (3.3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1.05, \"a\"), (2.13, \"b\"), (3.3, \"c\"), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"letter\"]) assert_approx_df_equality(df1, df2, 0.1) The assert_approx_df_equality method is smart and will only perform approximate equality operations for floating point numbers in DataFrames. It'll perform regular equality for strings and other types. Let's perform an approximate equality comparison for two DataFrames that are not equal. def test_approx_df_equality_different(): data1 = [ (1.1, \"a\"), (2.2, \"b\"), (3.3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1.1, \"a\"), (5.0, \"b\"), (3.3, \"z\"), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"letter\"]) assert_approx_df_equality(df1, df2, 0.1) Here's the pretty error message that's outputted:","title":"Approximate DataFrame equality"},{"location":"#schema-mismatch-messages","text":"DataFrame equality messages peform schema comparisons before analyzing the actual content of the DataFrames. DataFrames that don't have the same schemas should error out as fast as possible. Let's compare a DataFrame that has a string column an integer column with a DataFrame that has two integer columns to observe the schema mismatch message. def test_schema_mismatch_message(): data1 = [ (1, \"a\"), (2, \"b\"), (3, \"c\"), (None, None) ] df1 = spark.createDataFrame(data1, [\"num\", \"letter\"]) data2 = [ (1, 6), (2, 7), (3, 8), (None, None) ] df2 = spark.createDataFrame(data2, [\"num\", \"num2\"]) assert_df_equality(df1, df2) Here's the error message:","title":"Schema mismatch messages"},{"location":"#supported-pyspark-python-versions","text":"chispa currently supports PySpark 2.4+ and Python 3.5+. Use chispa v0.8.2 if you're using an older Python version. PySpark 2 support will be dropped when chispa 1.x is released.","title":"Supported PySpark / Python versions"},{"location":"#benchmarks","text":"TODO: Need to benchmark these methods vs. the spark-testing-base ones","title":"Benchmarks"},{"location":"#vendored-dependencies","text":"These dependencies are vendored: six PrettyTable The dependencies are vendored to save you from dependency hell.","title":"Vendored dependencies"},{"location":"#developing-chispa-on-your-local-machine","text":"You are encouraged to clone and/or fork this repo. This project uses Poetry for packaging and dependency management. Setup the virtual environment with poetry install Run the tests with poetry run pytest tests Studying the codebase is a great way to learn about PySpark!","title":"Developing chispa on your local machine"},{"location":"#contributing","text":"Anyone is encouraged to submit a pull request, open an issue, or submit a bug report. We're happy to promote folks to be library maintainers if they make good contributions.","title":"Contributing"},{"location":"reference/SUMMARY/","text":"chispa bcolors column_comparer dataframe_comparer default_formats number_helpers prettytable row_comparer rows_comparer schema_comparer six structfield_comparer terminal_str_formatter","title":"API Docs"},{"location":"reference/chispa/","text":"","title":"Index"},{"location":"reference/chispa/bcolors/","text":"underline_text(input_text) Takes an input string and returns a white, underlined string (based on PrettyTable formatting) Source code in chispa/bcolors.py def underline_text(input_text: str) -> str: \"\"\" Takes an input string and returns a white, underlined string (based on PrettyTable formatting) \"\"\" return bcolors.White + bcolors.Underline + input_text + bcolors.NC + bcolors.LightRed","title":"Bcolors"},{"location":"reference/chispa/bcolors/#chispa.bcolors.underline_text","text":"Takes an input string and returns a white, underlined string (based on PrettyTable formatting) Source code in chispa/bcolors.py def underline_text(input_text: str) -> str: \"\"\" Takes an input string and returns a white, underlined string (based on PrettyTable formatting) \"\"\" return bcolors.White + bcolors.Underline + input_text + bcolors.NC + bcolors.LightRed","title":"underline_text()"},{"location":"reference/chispa/column_comparer/","text":"ColumnsNotEqualError Bases: Exception The columns are not equal Source code in chispa/column_comparer.py class ColumnsNotEqualError(Exception): \"\"\"The columns are not equal\"\"\" pass","title":"Column comparer"},{"location":"reference/chispa/column_comparer/#chispa.column_comparer.ColumnsNotEqualError","text":"Bases: Exception The columns are not equal Source code in chispa/column_comparer.py class ColumnsNotEqualError(Exception): \"\"\"The columns are not equal\"\"\" pass","title":"ColumnsNotEqualError"},{"location":"reference/chispa/dataframe_comparer/","text":"DataFramesNotEqualError Bases: Exception The DataFrames are not equal Source code in chispa/dataframe_comparer.py class DataFramesNotEqualError(Exception): \"\"\"The DataFrames are not equal\"\"\" pass","title":"Dataframe comparer"},{"location":"reference/chispa/dataframe_comparer/#chispa.dataframe_comparer.DataFramesNotEqualError","text":"Bases: Exception The DataFrames are not equal Source code in chispa/dataframe_comparer.py class DataFramesNotEqualError(Exception): \"\"\"The DataFrames are not equal\"\"\" pass","title":"DataFramesNotEqualError"},{"location":"reference/chispa/default_formats/","text":"","title":"Default formats"},{"location":"reference/chispa/number_helpers/","text":"","title":"Number helpers"},{"location":"reference/chispa/prettytable/","text":"PrettyTable Bases: object Source code in chispa/prettytable.py class PrettyTable(object): def __init__(self, field_names=None, **kwargs): \"\"\"Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" self.encoding = kwargs.get(\"encoding\", \"UTF-8\") # Data self._field_names = [] self._rows = [] self.align = {} self.valign = {} self.max_width = {} self.min_width = {} self.int_format = {} self.float_format = {} if field_names: self.field_names = field_names else: self._widths = [] # Options self._options = ( \"title start end fields header border sortby reversesort \" \"sort_key attributes format hrules vrules\".split() ) self._options.extend( \"int_format float_format min_table_width max_table_width padding_width \" \"left_padding_width right_padding_width\".split() ) self._options.extend( \"vertical_char horizontal_char junction_char header_style valign xhtml \" \"print_empty oldsortslice\".split() ) self._options.extend(\"align valign max_width min_width\".split()) for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) else: kwargs[option] = None self._title = kwargs[\"title\"] or None self._start = kwargs[\"start\"] or 0 self._end = kwargs[\"end\"] or None self._fields = kwargs[\"fields\"] or None if kwargs[\"header\"] in (True, False): self._header = kwargs[\"header\"] else: self._header = True self._header_style = kwargs[\"header_style\"] or None if kwargs[\"border\"] in (True, False): self._border = kwargs[\"border\"] else: self._border = True self._hrules = kwargs[\"hrules\"] or FRAME self._vrules = kwargs[\"vrules\"] or ALL self._sortby = kwargs[\"sortby\"] or None if kwargs[\"reversesort\"] in (True, False): self._reversesort = kwargs[\"reversesort\"] else: self._reversesort = False self._sort_key = kwargs[\"sort_key\"] or (lambda x: x) # Column specific arguments, use property.setters self.align = kwargs[\"align\"] or {} self.valign = kwargs[\"valign\"] or {} self.max_width = kwargs[\"max_width\"] or {} self.min_width = kwargs[\"min_width\"] or {} self.int_format = kwargs[\"int_format\"] or {} self.float_format = kwargs[\"float_format\"] or {} self._min_table_width = kwargs[\"min_table_width\"] or None self._max_table_width = kwargs[\"max_table_width\"] or None self._padding_width = kwargs[\"padding_width\"] or 1 self._left_padding_width = kwargs[\"left_padding_width\"] or None self._right_padding_width = kwargs[\"right_padding_width\"] or None self._vertical_char = kwargs[\"vertical_char\"] or self._unicode(\"|\") self._horizontal_char = kwargs[\"horizontal_char\"] or self._unicode(\"-\") self._junction_char = kwargs[\"junction_char\"] or self._unicode(\"+\") if kwargs[\"print_empty\"] in (True, False): self._print_empty = kwargs[\"print_empty\"] else: self._print_empty = True if kwargs[\"oldsortslice\"] in (True, False): self._oldsortslice = kwargs[\"oldsortslice\"] else: self._oldsortslice = False self._format = kwargs[\"format\"] or False self._xhtml = kwargs[\"xhtml\"] or False self._attributes = kwargs[\"attributes\"] or {} def _unicode(self, value): if not isinstance(value, basestring): value = str(value) if not isinstance(value, unicode): value = unicode(value, self.encoding, \"strict\") return value def _justify(self, text, width, align): excess = width - _str_block_width(text) if align == \"l\": return text + excess * \" \" elif align == \"r\": return excess * \" \" + text else: if excess % 2: # Uneven padding # Put more space on right if text is of odd length... if _str_block_width(text) % 2: return (excess // 2) * \" \" + text + (excess // 2 + 1) * \" \" # and more space on left if text is of even length else: return (excess // 2 + 1) * \" \" + text + (excess // 2) * \" \" # Why distribute extra space this way? To match the behaviour of # the inbuilt str.center() method. else: # Equal padding on either side return (excess // 2) * \" \" + text + (excess // 2) * \" \" def __getattr__(self, name): if name == \"rowcount\": return len(self._rows) elif name == \"colcount\": if self._field_names: return len(self._field_names) elif self._rows: return len(self._rows[0]) else: return 0 else: raise AttributeError(name) def __getitem__(self, index): new = PrettyTable() new.field_names = self.field_names for attr in self._options: setattr(new, \"_\" + attr, getattr(self, \"_\" + attr)) setattr(new, \"_align\", getattr(self, \"_align\")) if isinstance(index, slice): for row in self._rows[index]: new.add_row(row) elif isinstance(index, int): new.add_row(self._rows[index]) else: raise Exception( \"Index %s is invalid, must be an integer or slice\" % str(index) ) return new if py3k: def __str__(self): return self.__unicode__() else: def __str__(self): return self.__unicode__().encode(self.encoding) def __unicode__(self): return self.get_string() ############################## # ATTRIBUTE VALIDATORS # ############################## # The method _validate_option is all that should be used elsewhere in the code base # to validate options. It will call the appropriate validation method for that # option. The individual validation methods should never need to be called directly # (although nothing bad will happen if they *are*). # Validation happens in TWO places. # Firstly, in the property setters defined in the ATTRIBUTE MANAGEMENT section. # Secondly, in the _get_options method, where keyword arguments are mixed with # persistent settings def _validate_option(self, option, val): if option in (\"field_names\"): self._validate_field_names(val) elif option in ( \"start\", \"end\", \"max_width\", \"min_width\", \"min_table_width\", \"max_table_width\", \"padding_width\", \"left_padding_width\", \"right_padding_width\", \"format\", ): self._validate_nonnegative_int(option, val) elif option in (\"sortby\"): self._validate_field_name(option, val) elif option in (\"sort_key\"): self._validate_function(option, val) elif option in (\"hrules\"): self._validate_hrules(option, val) elif option in (\"vrules\"): self._validate_vrules(option, val) elif option in (\"fields\"): self._validate_all_field_names(option, val) elif option in ( \"header\", \"border\", \"reversesort\", \"xhtml\", \"print_empty\", \"oldsortslice\", ): self._validate_true_or_false(option, val) elif option in (\"header_style\"): self._validate_header_style(val) elif option in (\"int_format\"): self._validate_int_format(option, val) elif option in (\"float_format\"): self._validate_float_format(option, val) elif option in (\"vertical_char\", \"horizontal_char\", \"junction_char\"): self._validate_single_char(option, val) elif option in (\"attributes\"): self._validate_attributes(option, val) def _validate_field_names(self, val): # Check for appropriate length if self._field_names: try: assert len(val) == len(self._field_names) except AssertionError: raise Exception( \"Field name list has incorrect number of values, \" \"(actual) %d!=%d (expected)\" % (len(val), len(self._field_names)) ) if self._rows: try: assert len(val) == len(self._rows[0]) except AssertionError: raise Exception( \"Field name list has incorrect number of values, \" \"(actual) %d!=%d (expected)\" % (len(val), len(self._rows[0])) ) # Check for uniqueness try: assert len(val) == len(set(val)) except AssertionError: raise Exception(\"Field names must be unique!\") def _validate_header_style(self, val): try: assert val in (\"cap\", \"title\", \"upper\", \"lower\", None) except AssertionError: raise Exception( \"Invalid header style, use cap, title, upper, lower or None!\" ) def _validate_align(self, val): try: assert val in [\"l\", \"c\", \"r\"] except AssertionError: raise Exception(\"Alignment %s is invalid, use l, c or r!\" % val) def _validate_valign(self, val): try: assert val in [\"t\", \"m\", \"b\", None] except AssertionError: raise Exception(\"Alignment %s is invalid, use t, m, b or None!\" % val) def _validate_nonnegative_int(self, name, val): try: assert int(val) >= 0 except AssertionError: raise Exception( \"Invalid value for {}: {}!\".format(name, self._unicode(val)) ) def _validate_true_or_false(self, name, val): try: assert val in (True, False) except AssertionError: raise Exception(\"Invalid value for %s! Must be True or False.\" % name) def _validate_int_format(self, name, val): if val == \"\": return try: assert type(val) in (str, unicode) assert val.isdigit() except AssertionError: raise Exception( \"Invalid value for %s! Must be an integer format string.\" % name ) def _validate_float_format(self, name, val): if val == \"\": return try: assert type(val) in (str, unicode) assert \".\" in val bits = val.split(\".\") assert len(bits) <= 2 assert bits[0] == \"\" or bits[0].isdigit() assert ( bits[1] == \"\" or bits[1].isdigit() or (bits[1][-1] == \"f\" and bits[1].rstrip(\"f\").isdigit()) ) except AssertionError: raise Exception( \"Invalid value for %s! Must be a float format string.\" % name ) def _validate_function(self, name, val): try: assert hasattr(val, \"__call__\") except AssertionError: raise Exception(\"Invalid value for %s! Must be a function.\" % name) def _validate_hrules(self, name, val): try: assert val in (ALL, FRAME, HEADER, NONE) except AssertionError: raise Exception( \"Invalid value for %s! Must be ALL, FRAME, HEADER or NONE.\" % name ) def _validate_vrules(self, name, val): try: assert val in (ALL, FRAME, NONE) except AssertionError: raise Exception( \"Invalid value for %s! Must be ALL, FRAME, or NONE.\" % name ) def _validate_field_name(self, name, val): try: assert (val in self._field_names) or (val is None) except AssertionError: raise Exception(\"Invalid field name: %s!\" % val) def _validate_all_field_names(self, name, val): try: for x in val: self._validate_field_name(name, x) except AssertionError: raise Exception(\"fields must be a sequence of field names!\") def _validate_single_char(self, name, val): try: assert _str_block_width(val) == 1 except AssertionError: raise Exception( \"Invalid value for %s! Must be a string of length 1.\" % name ) def _validate_attributes(self, name, val): try: assert isinstance(val, dict) except AssertionError: raise Exception(\"attributes must be a dictionary of name/value pairs!\") ############################## # ATTRIBUTE MANAGEMENT # ############################## @property def field_names(self): \"\"\"List or tuple of field names\"\"\" return self._field_names @field_names.setter def field_names(self, val): val = [self._unicode(x) for x in val] self._validate_option(\"field_names\", val) old_names = None if self._field_names: old_names = self._field_names[:] self._field_names = val if self._align and old_names: for old_name, new_name in zip(old_names, val): self._align[new_name] = self._align[old_name] for old_name in old_names: if old_name not in self._align: self._align.pop(old_name) else: self.align = \"c\" if self._valign and old_names: for old_name, new_name in zip(old_names, val): self._valign[new_name] = self._valign[old_name] for old_name in old_names: if old_name not in self._valign: self._valign.pop(old_name) else: self.valign = \"t\" @property def align(self): \"\"\"Controls alignment of fields Arguments: align - alignment, one of \"l\", \"c\", or \"r\" \"\"\" return self._align @align.setter def align(self, val): if not self._field_names: self._align = {} elif val is None or (isinstance(val, dict) and len(val) == 0): for field in self._field_names: self._align[field] = \"c\" else: self._validate_align(val) for field in self._field_names: self._align[field] = val @property def valign(self): \"\"\"Controls vertical alignment of fields Arguments: valign - vertical alignment, one of \"t\", \"m\", or \"b\" \"\"\" return self._valign @valign.setter def valign(self, val): if not self._field_names: self._valign = {} elif val is None or (isinstance(val, dict) and len(val) == 0): for field in self._field_names: self._valign[field] = \"t\" else: self._validate_valign(val) for field in self._field_names: self._valign[field] = val @property def max_width(self): \"\"\"Controls maximum width of fields Arguments: max_width - maximum width integer\"\"\" return self._max_width @max_width.setter def max_width(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._max_width = {} else: self._validate_option(\"max_width\", val) for field in self._field_names: self._max_width[field] = val @property def min_width(self): \"\"\"Controls minimum width of fields Arguments: min_width - minimum width integer\"\"\" return self._min_width @min_width.setter def min_width(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._min_width = {} else: self._validate_option(\"min_width\", val) for field in self._field_names: self._min_width[field] = val @property def min_table_width(self): return self._min_table_width @min_table_width.setter def min_table_width(self, val): self._validate_option(\"min_table_width\", val) self._min_table_width = val @property def max_table_width(self): return self._max_table_width @max_table_width.setter def max_table_width(self, val): self._validate_option(\"max_table_width\", val) self._max_table_width = val @property def fields(self): \"\"\"List or tuple of field names to include in displays\"\"\" return self._fields @fields.setter def fields(self, val): self._validate_option(\"fields\", val) self._fields = val @property def title(self): \"\"\"Optional table title Arguments: title - table title\"\"\" return self._title @title.setter def title(self, val): self._title = self._unicode(val) @property def start(self): \"\"\"Start index of the range of rows to print Arguments: start - index of first data row to include in output\"\"\" return self._start @start.setter def start(self, val): self._validate_option(\"start\", val) self._start = val @property def end(self): \"\"\"End index of the range of rows to print Arguments: end - index of last data row to include in output PLUS ONE (list slice style)\"\"\" return self._end @end.setter def end(self, val): self._validate_option(\"end\", val) self._end = val @property def sortby(self): \"\"\"Name of field by which to sort rows Arguments: sortby - field name to sort by\"\"\" return self._sortby @sortby.setter def sortby(self, val): self._validate_option(\"sortby\", val) self._sortby = val @property def reversesort(self): \"\"\"Controls direction of sorting (ascending vs descending) Arguments: reveresort - set to True to sort by descending order, or False to sort by ascending order\"\"\" return self._reversesort @reversesort.setter def reversesort(self, val): self._validate_option(\"reversesort\", val) self._reversesort = val @property def sort_key(self): \"\"\"Sorting key function, applied to data points before sorting Arguments: sort_key - a function which takes one argument and returns something to be sorted\"\"\" return self._sort_key @sort_key.setter def sort_key(self, val): self._validate_option(\"sort_key\", val) self._sort_key = val @property def header(self): \"\"\"Controls printing of table header with field names Arguments: header - print a header showing field names (True or False)\"\"\" return self._header @header.setter def header(self, val): self._validate_option(\"header\", val) self._header = val @property def header_style(self): \"\"\"Controls stylisation applied to field names in header Arguments: header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None)\"\"\" return self._header_style @header_style.setter def header_style(self, val): self._validate_header_style(val) self._header_style = val @property def border(self): \"\"\"Controls printing of border around table Arguments: border - print a border around the table (True or False)\"\"\" return self._border @border.setter def border(self, val): self._validate_option(\"border\", val) self._border = val @property def hrules(self): \"\"\"Controls printing of horizontal rules after rows Arguments: hrules - horizontal rules style. Allowed values: FRAME, ALL, HEADER, NONE\"\"\" return self._hrules @hrules.setter def hrules(self, val): self._validate_option(\"hrules\", val) self._hrules = val @property def vrules(self): \"\"\"Controls printing of vertical rules between columns Arguments: vrules - vertical rules style. Allowed values: FRAME, ALL, NONE\"\"\" return self._vrules @vrules.setter def vrules(self, val): self._validate_option(\"vrules\", val) self._vrules = val @property def int_format(self): \"\"\"Controls formatting of integer data Arguments: int_format - integer format string\"\"\" return self._int_format @int_format.setter def int_format(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._int_format = {} else: self._validate_option(\"int_format\", val) for field in self._field_names: self._int_format[field] = val @property def float_format(self): \"\"\"Controls formatting of floating point data Arguments: float_format - floating point format string\"\"\" return self._float_format @float_format.setter def float_format(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._float_format = {} else: self._validate_option(\"float_format\", val) for field in self._field_names: self._float_format[field] = val @property def padding_width(self): \"\"\"The number of empty spaces between a column's edge and its content Arguments: padding_width - number of spaces, must be a positive integer\"\"\" return self._padding_width @padding_width.setter def padding_width(self, val): self._validate_option(\"padding_width\", val) self._padding_width = val @property def left_padding_width(self): \"\"\"The number of empty spaces between a column's left edge and its content Arguments: left_padding - number of spaces, must be a positive integer\"\"\" return self._left_padding_width @left_padding_width.setter def left_padding_width(self, val): self._validate_option(\"left_padding_width\", val) self._left_padding_width = val @property def right_padding_width(self): \"\"\"The number of empty spaces between a column's right edge and its content Arguments: right_padding - number of spaces, must be a positive integer\"\"\" return self._right_padding_width @right_padding_width.setter def right_padding_width(self, val): self._validate_option(\"right_padding_width\", val) self._right_padding_width = val @property def vertical_char(self): \"\"\"The charcter used when printing table borders to draw vertical lines Arguments: vertical_char - single character string used to draw vertical lines\"\"\" return self._vertical_char @vertical_char.setter def vertical_char(self, val): val = self._unicode(val) self._validate_option(\"vertical_char\", val) self._vertical_char = val @property def horizontal_char(self): \"\"\"The charcter used when printing table borders to draw horizontal lines Arguments: horizontal_char - single character string used to draw horizontal lines\"\"\" return self._horizontal_char @horizontal_char.setter def horizontal_char(self, val): val = self._unicode(val) self._validate_option(\"horizontal_char\", val) self._horizontal_char = val @property def junction_char(self): \"\"\"The charcter used when printing table borders to draw line junctions Arguments: junction_char - single character string used to draw line junctions\"\"\" return self._junction_char @junction_char.setter def junction_char(self, val): val = self._unicode(val) self._validate_option(\"vertical_char\", val) self._junction_char = val @property def format(self): \"\"\"Controls whether or not HTML tables are formatted to match styling options Arguments: format - True or False\"\"\" return self._format @format.setter def format(self, val): self._validate_option(\"format\", val) self._format = val @property def print_empty(self): \"\"\"Controls whether or not empty tables produce a header and frame or just an empty string Arguments: print_empty - True or False\"\"\" return self._print_empty @print_empty.setter def print_empty(self, val): self._validate_option(\"print_empty\", val) self._print_empty = val @property def attributes(self): \"\"\"A dictionary of HTML attribute name/value pairs to be included in the <table> tag when printing HTML Arguments: attributes - dictionary of attributes\"\"\" return self._attributes @attributes.setter def attributes(self, val): self._validate_option(\"attributes\", val) self._attributes = val @property def oldsortslice(self): \"\"\" oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" return self._oldsortslice @oldsortslice.setter def oldsortslice(self, val): self._validate_option(\"oldsortslice\", val) self._oldsortslice = val ############################## # OPTION MIXER # ############################## def _get_options(self, kwargs): options = {} for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) options[option] = kwargs[option] else: options[option] = getattr(self, \"_\" + option) return options ############################## # PRESET STYLE LOGIC # ############################## def set_style(self, style): if style == DEFAULT: self._set_default_style() elif style == MSWORD_FRIENDLY: self._set_msword_style() elif style == PLAIN_COLUMNS: self._set_columns_style() elif style == MARKDOWN: self._set_markdown_style() elif style == RANDOM: self._set_random_style() else: raise Exception(\"Invalid pre-set style!\") def _set_markdown_style(self): self.header = True self.border = True self._hrules = None self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" self.junction_char = \"|\" def _set_default_style(self): self.header = True self.border = True self._hrules = FRAME self._vrules = ALL self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" self.horizontal_char = \"-\" self.junction_char = \"+\" def _set_msword_style(self): self.header = True self.border = True self._hrules = NONE self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" def _set_columns_style(self): self.header = True self.border = False self.padding_width = 1 self.left_padding_width = 0 self.right_padding_width = 8 def _set_random_style(self): # Just for fun! self.header = random.choice((True, False)) self.border = random.choice((True, False)) self._hrules = random.choice((ALL, FRAME, HEADER, NONE)) self._vrules = random.choice((ALL, FRAME, NONE)) self.left_padding_width = random.randint(0, 5) self.right_padding_width = random.randint(0, 5) self.vertical_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") self.horizontal_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") self.junction_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") ############################## # DATA INPUT METHODS # ############################## def add_row(self, row): \"\"\"Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields\"\"\" if self._field_names and len(row) != len(self._field_names): raise Exception( \"Row has incorrect number of values, (actual) %d!=%d (expected)\" % (len(row), len(self._field_names)) ) if not self._field_names: self.field_names = [(\"Field %d\" % (n + 1)) for n in range(0, len(row))] self._rows.append(list(row)) def del_row(self, row_index): \"\"\"Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0.\"\"\" if row_index > len(self._rows) - 1: raise Exception( \"Cant delete row at index %d, table only has %d rows!\" % (row_index, len(self._rows)) ) del self._rows[row_index] def add_column(self, fieldname, column, align=\"c\", valign=\"t\"): \"\"\"Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom\"\"\" if len(self._rows) in (0, len(column)): self._validate_align(align) self._validate_valign(valign) self._field_names.append(fieldname) self._align[fieldname] = align self._valign[fieldname] = valign for i in range(0, len(column)): if len(self._rows) < i + 1: self._rows.append([]) self._rows[i].append(column[i]) else: raise Exception( \"Column length %d does not match number of rows %d!\" % (len(column), len(self._rows)) ) def clear_rows(self): \"\"\"Delete all rows from the table but keep the current field names\"\"\" self._rows = [] def clear(self): \"\"\"Delete all rows and field names from the table, maintaining nothing but styling options\"\"\" self._rows = [] self._field_names = [] self._widths = [] ############################## # MISC PUBLIC METHODS # ############################## def copy(self): return copy.deepcopy(self) ############################## # MISC PRIVATE METHODS # ############################## def _format_value(self, field, value): if isinstance(value, int) and field in self._int_format: value = self._unicode((\"%%%sd\" % self._int_format[field]) % value) elif isinstance(value, float) and field in self._float_format: value = self._unicode((\"%%%sf\" % self._float_format[field]) % value) return self._unicode(value) def _compute_table_width(self, options): table_width = 2 if options[\"vrules\"] in (FRAME, ALL) else 0 per_col_padding = sum(self._get_padding_widths(options)) for index, fieldname in enumerate(self.field_names): if not options[\"fields\"] or ( options[\"fields\"] and fieldname in options[\"fields\"] ): table_width += self._widths[index] + per_col_padding return table_width def _compute_widths(self, rows, options): if options[\"header\"]: widths = [_get_size(field)[0] for field in self._field_names] else: widths = len(self.field_names) * [0] for row in rows: for index, value in enumerate(row): fieldname = self.field_names[index] if fieldname in self.max_width: widths[index] = max( widths[index], min(_get_size(value)[0], self.max_width[fieldname]), ) else: widths[index] = max(widths[index], _get_size(value)[0]) if fieldname in self.min_width: widths[index] = max(widths[index], self.min_width[fieldname]) self._widths = widths # Are we exceeding max_table_width? if self._max_table_width: table_width = self._compute_table_width(options) if table_width > self._max_table_width: # Shrink widths in proportion scale = 1.0 * self._max_table_width / table_width widths = [int(math.floor(w * scale)) for w in widths] self._widths = widths # Are we under min_table_width or title width? if self._min_table_width or options[\"title\"]: if options[\"title\"]: title_width = len(options[\"title\"]) + sum( self._get_padding_widths(options) ) if options[\"vrules\"] in (FRAME, ALL): title_width += 2 else: title_width = 0 min_table_width = self.min_table_width or 0 min_width = max(title_width, min_table_width) table_width = self._compute_table_width(options) if table_width < min_width: # Grow widths in proportion scale = 1.0 * min_width / table_width widths = [int(math.ceil(w * scale)) for w in widths] self._widths = widths def _get_padding_widths(self, options): if options[\"left_padding_width\"] is not None: lpad = options[\"left_padding_width\"] else: lpad = options[\"padding_width\"] if options[\"right_padding_width\"] is not None: rpad = options[\"right_padding_width\"] else: rpad = options[\"padding_width\"] return lpad, rpad def _get_rows(self, options): \"\"\"Return only those data rows that should be printed, based on slicing and sorting. Arguments: options - dictionary of option settings.\"\"\" if options[\"oldsortslice\"]: rows = copy.deepcopy(self._rows[options[\"start\"] : options[\"end\"]]) else: rows = copy.deepcopy(self._rows) # Sort if options[\"sortby\"]: sortindex = self._field_names.index(options[\"sortby\"]) # Decorate rows = [[row[sortindex]] + row for row in rows] # Sort rows.sort(reverse=options[\"reversesort\"], key=options[\"sort_key\"]) # Undecorate rows = [row[1:] for row in rows] # Slice if necessary if not options[\"oldsortslice\"]: rows = rows[options[\"start\"] : options[\"end\"]] return rows def _format_row(self, row, options): return [ self._format_value(field, value) for (field, value) in zip(self._field_names, row) ] def _format_rows(self, rows, options): return [self._format_row(row, options) for row in rows] ############################## # PLAIN TEXT STRING METHODS # ############################## def get_string(self, **kwargs): \"\"\"Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string \"\"\" options = self._get_options(kwargs) lines = [] # Don't think too hard about an empty table # Is this the desired behaviour? Maybe we should still print the header? if self.rowcount == 0 and (not options[\"print_empty\"] or not options[\"border\"]): return \"\" # Get the rows we need to print, taking into account slicing, sorting, etc. rows = self._get_rows(options) # Turn all data in all rows into Unicode, formatted as desired formatted_rows = self._format_rows(rows, options) # Compute column widths self._compute_widths(formatted_rows, options) self._hrule = self._stringify_hrule(options) # Add title title = options[\"title\"] or self._title if title: lines.append(self._stringify_title(title, options)) # Add header or top of border if options[\"header\"]: lines.append(self._stringify_header(options)) elif options[\"border\"] and options[\"hrules\"] in (ALL, FRAME): lines.append(self._hrule) # Add rows for row in formatted_rows: lines.append(self._stringify_row(row, options)) # Add bottom of border if options[\"border\"] and options[\"hrules\"] == FRAME: lines.append(self._hrule) return self._unicode(\"\\n\").join(lines) def _stringify_hrule(self, options): if not options[\"border\"]: return \"\" lpad, rpad = self._get_padding_widths(options) if options[\"vrules\"] in (ALL, FRAME): bits = [options[\"junction_char\"]] else: bits = [options[\"horizontal_char\"]] # For tables with no data or fieldnames if not self._field_names: bits.append(options[\"junction_char\"]) return \"\".join(bits) for field, width in zip(self._field_names, self._widths): if options[\"fields\"] and field not in options[\"fields\"]: continue bits.append((width + lpad + rpad) * options[\"horizontal_char\"]) if options[\"vrules\"] == ALL: bits.append(options[\"junction_char\"]) else: bits.append(options[\"horizontal_char\"]) if options[\"vrules\"] == FRAME: bits.pop() bits.append(options[\"junction_char\"]) return \"\".join(bits) def _stringify_title(self, title, options): lines = [] lpad, rpad = self._get_padding_widths(options) if options[\"border\"]: if options[\"vrules\"] == ALL: options[\"vrules\"] = FRAME lines.append(self._stringify_hrule(options)) options[\"vrules\"] = ALL elif options[\"vrules\"] == FRAME: lines.append(self._stringify_hrule(options)) bits = [] endpoint = ( options[\"vertical_char\"] if options[\"vrules\"] in (ALL, FRAME) else \" \" ) bits.append(endpoint) title = \" \" * lpad + title + \" \" * rpad bits.append(self._justify(title, len(self._hrule) - 2, \"c\")) bits.append(endpoint) lines.append(\"\".join(bits)) return \"\\n\".join(lines) def _stringify_header(self, options): bits = [] lpad, rpad = self._get_padding_widths(options) if options[\"border\"]: if options[\"hrules\"] in (ALL, FRAME): bits.append(self._hrule) bits.append(\"\\n\") if options[\"vrules\"] in (ALL, FRAME): bits.append(options[\"vertical_char\"]) else: bits.append(\" \") # For tables with no data or field names if not self._field_names: if options[\"vrules\"] in (ALL, FRAME): bits.append(options[\"vertical_char\"]) else: bits.append(\" \") for field, width, in zip(self._field_names, self._widths): if options[\"fields\"] and field not in options[\"fields\"]: continue if self._header_style == \"cap\": fieldname = field.capitalize() elif self._header_style == \"title\": fieldname = field.title() elif self._header_style == \"upper\": fieldname = field.upper() elif self._header_style == \"lower\": fieldname = field.lower() else: fieldname = field bits.append( \" \" * lpad + self._justify(fieldname, width, self._align[field]) + \" \" * rpad ) if options[\"border\"]: if options[\"vrules\"] == ALL: bits.append(options[\"vertical_char\"]) else: bits.append(\" \") # If vrules is FRAME, then we just appended a space at the end # of the last field, when we really want a vertical character if options[\"border\"] and options[\"vrules\"] == FRAME: bits.pop() bits.append(options[\"vertical_char\"]) if options[\"border\"] and options[\"hrules\"] != NONE: bits.append(\"\\n\") bits.append(self._hrule) return \"\".join(bits) def _stringify_row(self, row, options): for index, field, value, width, in zip( range(0, len(row)), self._field_names, row, self._widths ): # Enforce max widths lines = value.split(\"\\n\") new_lines = [] for line in lines: if _str_block_width(line) > width: line = textwrap.fill(line, width) new_lines.append(line) lines = new_lines value = \"\\n\".join(lines) row[index] = value row_height = 0 for c in row: h = _get_size(c)[1] if h > row_height: row_height = h bits = [] lpad, rpad = self._get_padding_widths(options) for y in range(0, row_height): bits.append([]) if options[\"border\"]: if options[\"vrules\"] in (ALL, FRAME): bits[y].append(self.vertical_char) else: bits[y].append(\" \") for field, value, width, in zip(self._field_names, row, self._widths): valign = self._valign[field] lines = value.split(\"\\n\") dHeight = row_height - len(lines) if dHeight: if valign == \"m\": lines = ( [\"\"] * int(dHeight / 2) + lines + [\"\"] * (dHeight - int(dHeight / 2)) ) elif valign == \"b\": lines = [\"\"] * dHeight + lines else: lines = lines + [\"\"] * dHeight y = 0 for l in lines: if options[\"fields\"] and field not in options[\"fields\"]: continue bits[y].append( \" \" * lpad + self._justify(l, width, self._align[field]) + \" \" * rpad ) if options[\"border\"]: if options[\"vrules\"] == ALL: bits[y].append(self.vertical_char) else: bits[y].append(\" \") y += 1 # If vrules is FRAME, then we just appended a space at the end # of the last field, when we really want a vertical character for y in range(0, row_height): if options[\"border\"] and options[\"vrules\"] == FRAME: bits[y].pop() bits[y].append(options[\"vertical_char\"]) if options[\"border\"] and options[\"hrules\"] == ALL: bits[row_height - 1].append(\"\\n\") bits[row_height - 1].append(self._hrule) for y in range(0, row_height): bits[y] = \"\".join(bits[y]) return \"\\n\".join(bits) def paginate(self, page_length=58, **kwargs): pages = [] kwargs[\"start\"] = kwargs.get(\"start\", 0) true_end = kwargs.get(\"end\", self.rowcount) while True: kwargs[\"end\"] = min(kwargs[\"start\"] + page_length, true_end) pages.append(self.get_string(**kwargs)) if kwargs[\"end\"] == true_end: break kwargs[\"start\"] += page_length return \"\\f\".join(pages) ############################## # JSON STRING METHODS # ############################## def get_json_string(self, **kwargs): \"\"\"Return string representation of JSON formatted table in the current state Arguments: none yet\"\"\" options = self._get_options(kwargs) objects = [self.field_names] for row in self._get_rows(options): objects.append(dict(zip(self._field_names, row))) return json.dumps(objects, indent=4, separators=(\",\", \": \"), sort_keys=True) ############################## # HTML STRING METHODS # ############################## def get_html_string(self, **kwargs): \"\"\"Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag xhtml - print <br/> tags if True, <br> tags if false\"\"\" options = self._get_options(kwargs) if options[\"format\"]: string = self._get_formatted_html_string(options) else: string = self._get_simple_html_string(options) return string def _get_simple_html_string(self, options): lines = [] if options[\"xhtml\"]: linebreak = \"<br/>\" else: linebreak = \"<br>\" open_tag = [\"<table\"] if options[\"attributes\"]: for attr_name in options[\"attributes\"]: open_tag.append( ' {}=\"{}\"'.format(attr_name, options[\"attributes\"][attr_name]) ) open_tag.append(\">\") lines.append(\"\".join(open_tag)) # Title title = options[\"title\"] or self._title if title: cols = ( len(options[\"fields\"]) if options[\"fields\"] else len(self.field_names) ) lines.append(\" <tr>\") lines.append(\" <td colspan=%d>%s</td>\" % (cols, title)) lines.append(\" </tr>\") # Headers if options[\"header\"]: lines.append(\" <tr>\") for field in self._field_names: if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( \" <th>%s</th>\" % escape(field).replace(\"\\n\", linebreak) ) lines.append(\" </tr>\") # Data rows = self._get_rows(options) formatted_rows = self._format_rows(rows, options) for row in formatted_rows: lines.append(\" <tr>\") for field, datum in zip(self._field_names, row): if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( \" <td>%s</td>\" % escape(datum).replace(\"\\n\", linebreak) ) lines.append(\" </tr>\") lines.append(\"</table>\") return self._unicode(\"\\n\").join(lines) def _get_formatted_html_string(self, options): lines = [] lpad, rpad = self._get_padding_widths(options) if options[\"xhtml\"]: linebreak = \"<br/>\" else: linebreak = \"<br>\" open_tag = [\"<table\"] if options[\"border\"]: if options[\"hrules\"] == ALL and options[\"vrules\"] == ALL: open_tag.append(' frame=\"box\" rules=\"all\"') elif options[\"hrules\"] == FRAME and options[\"vrules\"] == FRAME: open_tag.append(' frame=\"box\"') elif options[\"hrules\"] == FRAME and options[\"vrules\"] == ALL: open_tag.append(' frame=\"box\" rules=\"cols\"') elif options[\"hrules\"] == FRAME: open_tag.append(' frame=\"hsides\"') elif options[\"hrules\"] == ALL: open_tag.append(' frame=\"hsides\" rules=\"rows\"') elif options[\"vrules\"] == FRAME: open_tag.append(' frame=\"vsides\"') elif options[\"vrules\"] == ALL: open_tag.append(' frame=\"vsides\" rules=\"cols\"') if options[\"attributes\"]: for attr_name in options[\"attributes\"]: open_tag.append( ' {}=\"{}\"'.format(attr_name, options[\"attributes\"][attr_name]) ) open_tag.append(\">\") lines.append(\"\".join(open_tag)) # Title title = options[\"title\"] or self._title if title: cols = ( len(options[\"fields\"]) if options[\"fields\"] else len(self.field_names) ) lines.append(\" <tr>\") lines.append(\" <td colspan=%d>%s</td>\" % (cols, title)) lines.append(\" </tr>\") # Headers if options[\"header\"]: lines.append(\" <tr>\") for field in self._field_names: if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( ' <th style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</th>' # noqa: E501 % (lpad, rpad, escape(field).replace(\"\\n\", linebreak)) ) lines.append(\" </tr>\") # Data rows = self._get_rows(options) formatted_rows = self._format_rows(rows, options) aligns = [] valigns = [] for field in self._field_names: aligns.append( {\"l\": \"left\", \"r\": \"right\", \"c\": \"center\"}[self._align[field]] ) valigns.append( {\"t\": \"top\", \"m\": \"middle\", \"b\": \"bottom\"}[self._valign[field]] ) for row in formatted_rows: lines.append(\" <tr>\") for field, datum, align, valign in zip( self._field_names, row, aligns, valigns ): if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( ' <td style=\"padding-left: %dem; padding-right: %dem; text-align: %s; vertical-align: %s\">%s</td>' # noqa: E501 % ( lpad, rpad, align, valign, escape(datum).replace(\"\\n\", linebreak), ) ) lines.append(\" </tr>\") lines.append(\"</table>\") return self._unicode(\"\\n\").join(lines) align writable property Controls alignment of fields Arguments: align - alignment, one of \"l\", \"c\", or \"r\" attributes writable property A dictionary of HTML attribute name/value pairs to be included in the tag when printing HTML Arguments: attributes - dictionary of attributes border writable property Controls printing of border around table Arguments: border - print a border around the table (True or False) end writable property End index of the range of rows to print Arguments: end - index of last data row to include in output PLUS ONE (list slice style) field_names writable property List or tuple of field names fields writable property List or tuple of field names to include in displays float_format writable property Controls formatting of floating point data Arguments: float_format - floating point format string format writable property Controls whether or not HTML tables are formatted to match styling options Arguments: format - True or False header writable property Controls printing of table header with field names Arguments: header - print a header showing field names (True or False) header_style writable property Controls stylisation applied to field names in header Arguments: header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) horizontal_char writable property The charcter used when printing table borders to draw horizontal lines Arguments: horizontal_char - single character string used to draw horizontal lines hrules writable property Controls printing of horizontal rules after rows Arguments: hrules - horizontal rules style. Allowed values: FRAME, ALL, HEADER, NONE int_format writable property Controls formatting of integer data Arguments: int_format - integer format string junction_char writable property The charcter used when printing table borders to draw line junctions Arguments: junction_char - single character string used to draw line junctions left_padding_width writable property The number of empty spaces between a column's left edge and its content Arguments: left_padding - number of spaces, must be a positive integer max_width writable property Controls maximum width of fields Arguments: max_width - maximum width integer min_width writable property Controls minimum width of fields Arguments: min_width - minimum width integer oldsortslice writable property oldsortslice - Slice rows before sorting in the \"old style\" padding_width writable property The number of empty spaces between a column's edge and its content Arguments: padding_width - number of spaces, must be a positive integer print_empty writable property Controls whether or not empty tables produce a header and frame or just an empty string Arguments: print_empty - True or False reversesort writable property Controls direction of sorting (ascending vs descending) Arguments: reveresort - set to True to sort by descending order, or False to sort by ascending order right_padding_width writable property The number of empty spaces between a column's right edge and its content Arguments: right_padding - number of spaces, must be a positive integer sort_key writable property Sorting key function, applied to data points before sorting Arguments: sort_key - a function which takes one argument and returns something to be sorted sortby writable property Name of field by which to sort rows Arguments: sortby - field name to sort by start writable property Start index of the range of rows to print Arguments: start - index of first data row to include in output title writable property Optional table title Arguments: title - table title valign writable property Controls vertical alignment of fields Arguments: valign - vertical alignment, one of \"t\", \"m\", or \"b\" vertical_char writable property The charcter used when printing table borders to draw vertical lines Arguments: vertical_char - single character string used to draw vertical lines vrules writable property Controls printing of vertical rules between columns Arguments: vrules - vertical rules style. Allowed values: FRAME, ALL, NONE __init__(field_names=None, **kwargs) Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" Source code in chispa/prettytable.py def __init__(self, field_names=None, **kwargs): \"\"\"Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" self.encoding = kwargs.get(\"encoding\", \"UTF-8\") # Data self._field_names = [] self._rows = [] self.align = {} self.valign = {} self.max_width = {} self.min_width = {} self.int_format = {} self.float_format = {} if field_names: self.field_names = field_names else: self._widths = [] # Options self._options = ( \"title start end fields header border sortby reversesort \" \"sort_key attributes format hrules vrules\".split() ) self._options.extend( \"int_format float_format min_table_width max_table_width padding_width \" \"left_padding_width right_padding_width\".split() ) self._options.extend( \"vertical_char horizontal_char junction_char header_style valign xhtml \" \"print_empty oldsortslice\".split() ) self._options.extend(\"align valign max_width min_width\".split()) for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) else: kwargs[option] = None self._title = kwargs[\"title\"] or None self._start = kwargs[\"start\"] or 0 self._end = kwargs[\"end\"] or None self._fields = kwargs[\"fields\"] or None if kwargs[\"header\"] in (True, False): self._header = kwargs[\"header\"] else: self._header = True self._header_style = kwargs[\"header_style\"] or None if kwargs[\"border\"] in (True, False): self._border = kwargs[\"border\"] else: self._border = True self._hrules = kwargs[\"hrules\"] or FRAME self._vrules = kwargs[\"vrules\"] or ALL self._sortby = kwargs[\"sortby\"] or None if kwargs[\"reversesort\"] in (True, False): self._reversesort = kwargs[\"reversesort\"] else: self._reversesort = False self._sort_key = kwargs[\"sort_key\"] or (lambda x: x) # Column specific arguments, use property.setters self.align = kwargs[\"align\"] or {} self.valign = kwargs[\"valign\"] or {} self.max_width = kwargs[\"max_width\"] or {} self.min_width = kwargs[\"min_width\"] or {} self.int_format = kwargs[\"int_format\"] or {} self.float_format = kwargs[\"float_format\"] or {} self._min_table_width = kwargs[\"min_table_width\"] or None self._max_table_width = kwargs[\"max_table_width\"] or None self._padding_width = kwargs[\"padding_width\"] or 1 self._left_padding_width = kwargs[\"left_padding_width\"] or None self._right_padding_width = kwargs[\"right_padding_width\"] or None self._vertical_char = kwargs[\"vertical_char\"] or self._unicode(\"|\") self._horizontal_char = kwargs[\"horizontal_char\"] or self._unicode(\"-\") self._junction_char = kwargs[\"junction_char\"] or self._unicode(\"+\") if kwargs[\"print_empty\"] in (True, False): self._print_empty = kwargs[\"print_empty\"] else: self._print_empty = True if kwargs[\"oldsortslice\"] in (True, False): self._oldsortslice = kwargs[\"oldsortslice\"] else: self._oldsortslice = False self._format = kwargs[\"format\"] or False self._xhtml = kwargs[\"xhtml\"] or False self._attributes = kwargs[\"attributes\"] or {} add_column(fieldname, column, align='c', valign='t') Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom Source code in chispa/prettytable.py def add_column(self, fieldname, column, align=\"c\", valign=\"t\"): \"\"\"Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom\"\"\" if len(self._rows) in (0, len(column)): self._validate_align(align) self._validate_valign(valign) self._field_names.append(fieldname) self._align[fieldname] = align self._valign[fieldname] = valign for i in range(0, len(column)): if len(self._rows) < i + 1: self._rows.append([]) self._rows[i].append(column[i]) else: raise Exception( \"Column length %d does not match number of rows %d!\" % (len(column), len(self._rows)) ) add_row(row) Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields Source code in chispa/prettytable.py def add_row(self, row): \"\"\"Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields\"\"\" if self._field_names and len(row) != len(self._field_names): raise Exception( \"Row has incorrect number of values, (actual) %d!=%d (expected)\" % (len(row), len(self._field_names)) ) if not self._field_names: self.field_names = [(\"Field %d\" % (n + 1)) for n in range(0, len(row))] self._rows.append(list(row)) clear() Delete all rows and field names from the table, maintaining nothing but styling options Source code in chispa/prettytable.py def clear(self): \"\"\"Delete all rows and field names from the table, maintaining nothing but styling options\"\"\" self._rows = [] self._field_names = [] self._widths = [] clear_rows() Delete all rows from the table but keep the current field names Source code in chispa/prettytable.py def clear_rows(self): \"\"\"Delete all rows from the table but keep the current field names\"\"\" self._rows = [] del_row(row_index) Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0. Source code in chispa/prettytable.py def del_row(self, row_index): \"\"\"Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0.\"\"\" if row_index > len(self._rows) - 1: raise Exception( \"Cant delete row at index %d, table only has %d rows!\" % (row_index, len(self._rows)) ) del self._rows[row_index] get_html_string(**kwargs) Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the tag xhtml - print tags if True, tags if false Source code in chispa/prettytable.py def get_html_string(self, **kwargs): \"\"\"Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag xhtml - print <br/> tags if True, <br> tags if false\"\"\" options = self._get_options(kwargs) if options[\"format\"]: string = self._get_formatted_html_string(options) else: string = self._get_simple_html_string(options) return string get_json_string(**kwargs) Return string representation of JSON formatted table in the current state Arguments: none yet Source code in chispa/prettytable.py def get_json_string(self, **kwargs): \"\"\"Return string representation of JSON formatted table in the current state Arguments: none yet\"\"\" options = self._get_options(kwargs) objects = [self.field_names] for row in self._get_rows(options): objects.append(dict(zip(self._field_names, row))) return json.dumps(objects, indent=4, separators=(\",\", \": \"), sort_keys=True) get_string(**kwargs) Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string Source code in chispa/prettytable.py def get_string(self, **kwargs): \"\"\"Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string \"\"\" options = self._get_options(kwargs) lines = [] # Don't think too hard about an empty table # Is this the desired behaviour? Maybe we should still print the header? if self.rowcount == 0 and (not options[\"print_empty\"] or not options[\"border\"]): return \"\" # Get the rows we need to print, taking into account slicing, sorting, etc. rows = self._get_rows(options) # Turn all data in all rows into Unicode, formatted as desired formatted_rows = self._format_rows(rows, options) # Compute column widths self._compute_widths(formatted_rows, options) self._hrule = self._stringify_hrule(options) # Add title title = options[\"title\"] or self._title if title: lines.append(self._stringify_title(title, options)) # Add header or top of border if options[\"header\"]: lines.append(self._stringify_header(options)) elif options[\"border\"] and options[\"hrules\"] in (ALL, FRAME): lines.append(self._hrule) # Add rows for row in formatted_rows: lines.append(self._stringify_row(row, options)) # Add bottom of border if options[\"border\"] and options[\"hrules\"] == FRAME: lines.append(self._hrule) return self._unicode(\"\\n\").join(lines) TableHandler Bases: HTMLParser Source code in chispa/prettytable.py class TableHandler(HTMLParser): def __init__(self, **kwargs): HTMLParser.__init__(self) self.kwargs = kwargs self.tables = [] self.last_row = [] self.rows = [] self.max_row_width = 0 self.active = None self.last_content = \"\" self.is_last_row_header = False self.colspan = 0 def handle_starttag(self, tag, attrs): self.active = tag if tag == \"th\": self.is_last_row_header = True for (key, value) in attrs: if key == \"colspan\": self.colspan = int(value) def handle_endtag(self, tag): if tag in [\"th\", \"td\"]: stripped_content = self.last_content.strip() self.last_row.append(stripped_content) if self.colspan: for i in range(1, self.colspan): self.last_row.append(\"\") self.colspan = 0 if tag == \"tr\": self.rows.append((self.last_row, self.is_last_row_header)) self.max_row_width = max(self.max_row_width, len(self.last_row)) self.last_row = [] self.is_last_row_header = False if tag == \"table\": table = self.generate_table(self.rows) self.tables.append(table) self.rows = [] self.last_content = \" \" self.active = None def handle_data(self, data): self.last_content += data def generate_table(self, rows): \"\"\" Generates from a list of rows a PrettyTable object. \"\"\" table = PrettyTable(**self.kwargs) for row in self.rows: if len(row[0]) < self.max_row_width: appends = self.max_row_width - len(row[0]) for i in range(1, appends): row[0].append(\"-\") if row[1]: self.make_fields_unique(row[0]) table.field_names = row[0] else: table.add_row(row[0]) return table def make_fields_unique(self, fields): \"\"\" iterates over the row and make each field unique \"\"\" for i in range(0, len(fields)): for j in range(i + 1, len(fields)): if fields[i] == fields[j]: fields[j] += \"'\" generate_table(rows) Generates from a list of rows a PrettyTable object. Source code in chispa/prettytable.py def generate_table(self, rows): \"\"\" Generates from a list of rows a PrettyTable object. \"\"\" table = PrettyTable(**self.kwargs) for row in self.rows: if len(row[0]) < self.max_row_width: appends = self.max_row_width - len(row[0]) for i in range(1, appends): row[0].append(\"-\") if row[1]: self.make_fields_unique(row[0]) table.field_names = row[0] else: table.add_row(row[0]) return table make_fields_unique(fields) iterates over the row and make each field unique Source code in chispa/prettytable.py def make_fields_unique(self, fields): \"\"\" iterates over the row and make each field unique \"\"\" for i in range(0, len(fields)): for j in range(i + 1, len(fields)): if fields[i] == fields[j]: fields[j] += \"'\" from_html(html_code, **kwargs) Generates a list of PrettyTables from a string of HTML code. Each in the HTML becomes one PrettyTable object. Source code in chispa/prettytable.py def from_html(html_code, **kwargs): \"\"\" Generates a list of PrettyTables from a string of HTML code. Each <table> in the HTML becomes one PrettyTable object. \"\"\" parser = TableHandler(**kwargs) parser.feed(html_code) return parser.tables from_html_one(html_code, **kwargs) Generates a PrettyTables from a string of HTML code which contains only a single Source code in chispa/prettytable.py def from_html_one(html_code, **kwargs): \"\"\" Generates a PrettyTables from a string of HTML code which contains only a single <table> \"\"\" tables = from_html(html_code, **kwargs) try: assert len(tables) == 1 except AssertionError: raise Exception( \"More than one <table> in provided HTML code! Use from_html instead.\" ) return tables[0]","title":"Prettytable"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable","text":"Bases: object Source code in chispa/prettytable.py class PrettyTable(object): def __init__(self, field_names=None, **kwargs): \"\"\"Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" self.encoding = kwargs.get(\"encoding\", \"UTF-8\") # Data self._field_names = [] self._rows = [] self.align = {} self.valign = {} self.max_width = {} self.min_width = {} self.int_format = {} self.float_format = {} if field_names: self.field_names = field_names else: self._widths = [] # Options self._options = ( \"title start end fields header border sortby reversesort \" \"sort_key attributes format hrules vrules\".split() ) self._options.extend( \"int_format float_format min_table_width max_table_width padding_width \" \"left_padding_width right_padding_width\".split() ) self._options.extend( \"vertical_char horizontal_char junction_char header_style valign xhtml \" \"print_empty oldsortslice\".split() ) self._options.extend(\"align valign max_width min_width\".split()) for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) else: kwargs[option] = None self._title = kwargs[\"title\"] or None self._start = kwargs[\"start\"] or 0 self._end = kwargs[\"end\"] or None self._fields = kwargs[\"fields\"] or None if kwargs[\"header\"] in (True, False): self._header = kwargs[\"header\"] else: self._header = True self._header_style = kwargs[\"header_style\"] or None if kwargs[\"border\"] in (True, False): self._border = kwargs[\"border\"] else: self._border = True self._hrules = kwargs[\"hrules\"] or FRAME self._vrules = kwargs[\"vrules\"] or ALL self._sortby = kwargs[\"sortby\"] or None if kwargs[\"reversesort\"] in (True, False): self._reversesort = kwargs[\"reversesort\"] else: self._reversesort = False self._sort_key = kwargs[\"sort_key\"] or (lambda x: x) # Column specific arguments, use property.setters self.align = kwargs[\"align\"] or {} self.valign = kwargs[\"valign\"] or {} self.max_width = kwargs[\"max_width\"] or {} self.min_width = kwargs[\"min_width\"] or {} self.int_format = kwargs[\"int_format\"] or {} self.float_format = kwargs[\"float_format\"] or {} self._min_table_width = kwargs[\"min_table_width\"] or None self._max_table_width = kwargs[\"max_table_width\"] or None self._padding_width = kwargs[\"padding_width\"] or 1 self._left_padding_width = kwargs[\"left_padding_width\"] or None self._right_padding_width = kwargs[\"right_padding_width\"] or None self._vertical_char = kwargs[\"vertical_char\"] or self._unicode(\"|\") self._horizontal_char = kwargs[\"horizontal_char\"] or self._unicode(\"-\") self._junction_char = kwargs[\"junction_char\"] or self._unicode(\"+\") if kwargs[\"print_empty\"] in (True, False): self._print_empty = kwargs[\"print_empty\"] else: self._print_empty = True if kwargs[\"oldsortslice\"] in (True, False): self._oldsortslice = kwargs[\"oldsortslice\"] else: self._oldsortslice = False self._format = kwargs[\"format\"] or False self._xhtml = kwargs[\"xhtml\"] or False self._attributes = kwargs[\"attributes\"] or {} def _unicode(self, value): if not isinstance(value, basestring): value = str(value) if not isinstance(value, unicode): value = unicode(value, self.encoding, \"strict\") return value def _justify(self, text, width, align): excess = width - _str_block_width(text) if align == \"l\": return text + excess * \" \" elif align == \"r\": return excess * \" \" + text else: if excess % 2: # Uneven padding # Put more space on right if text is of odd length... if _str_block_width(text) % 2: return (excess // 2) * \" \" + text + (excess // 2 + 1) * \" \" # and more space on left if text is of even length else: return (excess // 2 + 1) * \" \" + text + (excess // 2) * \" \" # Why distribute extra space this way? To match the behaviour of # the inbuilt str.center() method. else: # Equal padding on either side return (excess // 2) * \" \" + text + (excess // 2) * \" \" def __getattr__(self, name): if name == \"rowcount\": return len(self._rows) elif name == \"colcount\": if self._field_names: return len(self._field_names) elif self._rows: return len(self._rows[0]) else: return 0 else: raise AttributeError(name) def __getitem__(self, index): new = PrettyTable() new.field_names = self.field_names for attr in self._options: setattr(new, \"_\" + attr, getattr(self, \"_\" + attr)) setattr(new, \"_align\", getattr(self, \"_align\")) if isinstance(index, slice): for row in self._rows[index]: new.add_row(row) elif isinstance(index, int): new.add_row(self._rows[index]) else: raise Exception( \"Index %s is invalid, must be an integer or slice\" % str(index) ) return new if py3k: def __str__(self): return self.__unicode__() else: def __str__(self): return self.__unicode__().encode(self.encoding) def __unicode__(self): return self.get_string() ############################## # ATTRIBUTE VALIDATORS # ############################## # The method _validate_option is all that should be used elsewhere in the code base # to validate options. It will call the appropriate validation method for that # option. The individual validation methods should never need to be called directly # (although nothing bad will happen if they *are*). # Validation happens in TWO places. # Firstly, in the property setters defined in the ATTRIBUTE MANAGEMENT section. # Secondly, in the _get_options method, where keyword arguments are mixed with # persistent settings def _validate_option(self, option, val): if option in (\"field_names\"): self._validate_field_names(val) elif option in ( \"start\", \"end\", \"max_width\", \"min_width\", \"min_table_width\", \"max_table_width\", \"padding_width\", \"left_padding_width\", \"right_padding_width\", \"format\", ): self._validate_nonnegative_int(option, val) elif option in (\"sortby\"): self._validate_field_name(option, val) elif option in (\"sort_key\"): self._validate_function(option, val) elif option in (\"hrules\"): self._validate_hrules(option, val) elif option in (\"vrules\"): self._validate_vrules(option, val) elif option in (\"fields\"): self._validate_all_field_names(option, val) elif option in ( \"header\", \"border\", \"reversesort\", \"xhtml\", \"print_empty\", \"oldsortslice\", ): self._validate_true_or_false(option, val) elif option in (\"header_style\"): self._validate_header_style(val) elif option in (\"int_format\"): self._validate_int_format(option, val) elif option in (\"float_format\"): self._validate_float_format(option, val) elif option in (\"vertical_char\", \"horizontal_char\", \"junction_char\"): self._validate_single_char(option, val) elif option in (\"attributes\"): self._validate_attributes(option, val) def _validate_field_names(self, val): # Check for appropriate length if self._field_names: try: assert len(val) == len(self._field_names) except AssertionError: raise Exception( \"Field name list has incorrect number of values, \" \"(actual) %d!=%d (expected)\" % (len(val), len(self._field_names)) ) if self._rows: try: assert len(val) == len(self._rows[0]) except AssertionError: raise Exception( \"Field name list has incorrect number of values, \" \"(actual) %d!=%d (expected)\" % (len(val), len(self._rows[0])) ) # Check for uniqueness try: assert len(val) == len(set(val)) except AssertionError: raise Exception(\"Field names must be unique!\") def _validate_header_style(self, val): try: assert val in (\"cap\", \"title\", \"upper\", \"lower\", None) except AssertionError: raise Exception( \"Invalid header style, use cap, title, upper, lower or None!\" ) def _validate_align(self, val): try: assert val in [\"l\", \"c\", \"r\"] except AssertionError: raise Exception(\"Alignment %s is invalid, use l, c or r!\" % val) def _validate_valign(self, val): try: assert val in [\"t\", \"m\", \"b\", None] except AssertionError: raise Exception(\"Alignment %s is invalid, use t, m, b or None!\" % val) def _validate_nonnegative_int(self, name, val): try: assert int(val) >= 0 except AssertionError: raise Exception( \"Invalid value for {}: {}!\".format(name, self._unicode(val)) ) def _validate_true_or_false(self, name, val): try: assert val in (True, False) except AssertionError: raise Exception(\"Invalid value for %s! Must be True or False.\" % name) def _validate_int_format(self, name, val): if val == \"\": return try: assert type(val) in (str, unicode) assert val.isdigit() except AssertionError: raise Exception( \"Invalid value for %s! Must be an integer format string.\" % name ) def _validate_float_format(self, name, val): if val == \"\": return try: assert type(val) in (str, unicode) assert \".\" in val bits = val.split(\".\") assert len(bits) <= 2 assert bits[0] == \"\" or bits[0].isdigit() assert ( bits[1] == \"\" or bits[1].isdigit() or (bits[1][-1] == \"f\" and bits[1].rstrip(\"f\").isdigit()) ) except AssertionError: raise Exception( \"Invalid value for %s! Must be a float format string.\" % name ) def _validate_function(self, name, val): try: assert hasattr(val, \"__call__\") except AssertionError: raise Exception(\"Invalid value for %s! Must be a function.\" % name) def _validate_hrules(self, name, val): try: assert val in (ALL, FRAME, HEADER, NONE) except AssertionError: raise Exception( \"Invalid value for %s! Must be ALL, FRAME, HEADER or NONE.\" % name ) def _validate_vrules(self, name, val): try: assert val in (ALL, FRAME, NONE) except AssertionError: raise Exception( \"Invalid value for %s! Must be ALL, FRAME, or NONE.\" % name ) def _validate_field_name(self, name, val): try: assert (val in self._field_names) or (val is None) except AssertionError: raise Exception(\"Invalid field name: %s!\" % val) def _validate_all_field_names(self, name, val): try: for x in val: self._validate_field_name(name, x) except AssertionError: raise Exception(\"fields must be a sequence of field names!\") def _validate_single_char(self, name, val): try: assert _str_block_width(val) == 1 except AssertionError: raise Exception( \"Invalid value for %s! Must be a string of length 1.\" % name ) def _validate_attributes(self, name, val): try: assert isinstance(val, dict) except AssertionError: raise Exception(\"attributes must be a dictionary of name/value pairs!\") ############################## # ATTRIBUTE MANAGEMENT # ############################## @property def field_names(self): \"\"\"List or tuple of field names\"\"\" return self._field_names @field_names.setter def field_names(self, val): val = [self._unicode(x) for x in val] self._validate_option(\"field_names\", val) old_names = None if self._field_names: old_names = self._field_names[:] self._field_names = val if self._align and old_names: for old_name, new_name in zip(old_names, val): self._align[new_name] = self._align[old_name] for old_name in old_names: if old_name not in self._align: self._align.pop(old_name) else: self.align = \"c\" if self._valign and old_names: for old_name, new_name in zip(old_names, val): self._valign[new_name] = self._valign[old_name] for old_name in old_names: if old_name not in self._valign: self._valign.pop(old_name) else: self.valign = \"t\" @property def align(self): \"\"\"Controls alignment of fields Arguments: align - alignment, one of \"l\", \"c\", or \"r\" \"\"\" return self._align @align.setter def align(self, val): if not self._field_names: self._align = {} elif val is None or (isinstance(val, dict) and len(val) == 0): for field in self._field_names: self._align[field] = \"c\" else: self._validate_align(val) for field in self._field_names: self._align[field] = val @property def valign(self): \"\"\"Controls vertical alignment of fields Arguments: valign - vertical alignment, one of \"t\", \"m\", or \"b\" \"\"\" return self._valign @valign.setter def valign(self, val): if not self._field_names: self._valign = {} elif val is None or (isinstance(val, dict) and len(val) == 0): for field in self._field_names: self._valign[field] = \"t\" else: self._validate_valign(val) for field in self._field_names: self._valign[field] = val @property def max_width(self): \"\"\"Controls maximum width of fields Arguments: max_width - maximum width integer\"\"\" return self._max_width @max_width.setter def max_width(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._max_width = {} else: self._validate_option(\"max_width\", val) for field in self._field_names: self._max_width[field] = val @property def min_width(self): \"\"\"Controls minimum width of fields Arguments: min_width - minimum width integer\"\"\" return self._min_width @min_width.setter def min_width(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._min_width = {} else: self._validate_option(\"min_width\", val) for field in self._field_names: self._min_width[field] = val @property def min_table_width(self): return self._min_table_width @min_table_width.setter def min_table_width(self, val): self._validate_option(\"min_table_width\", val) self._min_table_width = val @property def max_table_width(self): return self._max_table_width @max_table_width.setter def max_table_width(self, val): self._validate_option(\"max_table_width\", val) self._max_table_width = val @property def fields(self): \"\"\"List or tuple of field names to include in displays\"\"\" return self._fields @fields.setter def fields(self, val): self._validate_option(\"fields\", val) self._fields = val @property def title(self): \"\"\"Optional table title Arguments: title - table title\"\"\" return self._title @title.setter def title(self, val): self._title = self._unicode(val) @property def start(self): \"\"\"Start index of the range of rows to print Arguments: start - index of first data row to include in output\"\"\" return self._start @start.setter def start(self, val): self._validate_option(\"start\", val) self._start = val @property def end(self): \"\"\"End index of the range of rows to print Arguments: end - index of last data row to include in output PLUS ONE (list slice style)\"\"\" return self._end @end.setter def end(self, val): self._validate_option(\"end\", val) self._end = val @property def sortby(self): \"\"\"Name of field by which to sort rows Arguments: sortby - field name to sort by\"\"\" return self._sortby @sortby.setter def sortby(self, val): self._validate_option(\"sortby\", val) self._sortby = val @property def reversesort(self): \"\"\"Controls direction of sorting (ascending vs descending) Arguments: reveresort - set to True to sort by descending order, or False to sort by ascending order\"\"\" return self._reversesort @reversesort.setter def reversesort(self, val): self._validate_option(\"reversesort\", val) self._reversesort = val @property def sort_key(self): \"\"\"Sorting key function, applied to data points before sorting Arguments: sort_key - a function which takes one argument and returns something to be sorted\"\"\" return self._sort_key @sort_key.setter def sort_key(self, val): self._validate_option(\"sort_key\", val) self._sort_key = val @property def header(self): \"\"\"Controls printing of table header with field names Arguments: header - print a header showing field names (True or False)\"\"\" return self._header @header.setter def header(self, val): self._validate_option(\"header\", val) self._header = val @property def header_style(self): \"\"\"Controls stylisation applied to field names in header Arguments: header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None)\"\"\" return self._header_style @header_style.setter def header_style(self, val): self._validate_header_style(val) self._header_style = val @property def border(self): \"\"\"Controls printing of border around table Arguments: border - print a border around the table (True or False)\"\"\" return self._border @border.setter def border(self, val): self._validate_option(\"border\", val) self._border = val @property def hrules(self): \"\"\"Controls printing of horizontal rules after rows Arguments: hrules - horizontal rules style. Allowed values: FRAME, ALL, HEADER, NONE\"\"\" return self._hrules @hrules.setter def hrules(self, val): self._validate_option(\"hrules\", val) self._hrules = val @property def vrules(self): \"\"\"Controls printing of vertical rules between columns Arguments: vrules - vertical rules style. Allowed values: FRAME, ALL, NONE\"\"\" return self._vrules @vrules.setter def vrules(self, val): self._validate_option(\"vrules\", val) self._vrules = val @property def int_format(self): \"\"\"Controls formatting of integer data Arguments: int_format - integer format string\"\"\" return self._int_format @int_format.setter def int_format(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._int_format = {} else: self._validate_option(\"int_format\", val) for field in self._field_names: self._int_format[field] = val @property def float_format(self): \"\"\"Controls formatting of floating point data Arguments: float_format - floating point format string\"\"\" return self._float_format @float_format.setter def float_format(self, val): if val is None or (isinstance(val, dict) and len(val) == 0): self._float_format = {} else: self._validate_option(\"float_format\", val) for field in self._field_names: self._float_format[field] = val @property def padding_width(self): \"\"\"The number of empty spaces between a column's edge and its content Arguments: padding_width - number of spaces, must be a positive integer\"\"\" return self._padding_width @padding_width.setter def padding_width(self, val): self._validate_option(\"padding_width\", val) self._padding_width = val @property def left_padding_width(self): \"\"\"The number of empty spaces between a column's left edge and its content Arguments: left_padding - number of spaces, must be a positive integer\"\"\" return self._left_padding_width @left_padding_width.setter def left_padding_width(self, val): self._validate_option(\"left_padding_width\", val) self._left_padding_width = val @property def right_padding_width(self): \"\"\"The number of empty spaces between a column's right edge and its content Arguments: right_padding - number of spaces, must be a positive integer\"\"\" return self._right_padding_width @right_padding_width.setter def right_padding_width(self, val): self._validate_option(\"right_padding_width\", val) self._right_padding_width = val @property def vertical_char(self): \"\"\"The charcter used when printing table borders to draw vertical lines Arguments: vertical_char - single character string used to draw vertical lines\"\"\" return self._vertical_char @vertical_char.setter def vertical_char(self, val): val = self._unicode(val) self._validate_option(\"vertical_char\", val) self._vertical_char = val @property def horizontal_char(self): \"\"\"The charcter used when printing table borders to draw horizontal lines Arguments: horizontal_char - single character string used to draw horizontal lines\"\"\" return self._horizontal_char @horizontal_char.setter def horizontal_char(self, val): val = self._unicode(val) self._validate_option(\"horizontal_char\", val) self._horizontal_char = val @property def junction_char(self): \"\"\"The charcter used when printing table borders to draw line junctions Arguments: junction_char - single character string used to draw line junctions\"\"\" return self._junction_char @junction_char.setter def junction_char(self, val): val = self._unicode(val) self._validate_option(\"vertical_char\", val) self._junction_char = val @property def format(self): \"\"\"Controls whether or not HTML tables are formatted to match styling options Arguments: format - True or False\"\"\" return self._format @format.setter def format(self, val): self._validate_option(\"format\", val) self._format = val @property def print_empty(self): \"\"\"Controls whether or not empty tables produce a header and frame or just an empty string Arguments: print_empty - True or False\"\"\" return self._print_empty @print_empty.setter def print_empty(self, val): self._validate_option(\"print_empty\", val) self._print_empty = val @property def attributes(self): \"\"\"A dictionary of HTML attribute name/value pairs to be included in the <table> tag when printing HTML Arguments: attributes - dictionary of attributes\"\"\" return self._attributes @attributes.setter def attributes(self, val): self._validate_option(\"attributes\", val) self._attributes = val @property def oldsortslice(self): \"\"\" oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" return self._oldsortslice @oldsortslice.setter def oldsortslice(self, val): self._validate_option(\"oldsortslice\", val) self._oldsortslice = val ############################## # OPTION MIXER # ############################## def _get_options(self, kwargs): options = {} for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) options[option] = kwargs[option] else: options[option] = getattr(self, \"_\" + option) return options ############################## # PRESET STYLE LOGIC # ############################## def set_style(self, style): if style == DEFAULT: self._set_default_style() elif style == MSWORD_FRIENDLY: self._set_msword_style() elif style == PLAIN_COLUMNS: self._set_columns_style() elif style == MARKDOWN: self._set_markdown_style() elif style == RANDOM: self._set_random_style() else: raise Exception(\"Invalid pre-set style!\") def _set_markdown_style(self): self.header = True self.border = True self._hrules = None self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" self.junction_char = \"|\" def _set_default_style(self): self.header = True self.border = True self._hrules = FRAME self._vrules = ALL self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" self.horizontal_char = \"-\" self.junction_char = \"+\" def _set_msword_style(self): self.header = True self.border = True self._hrules = NONE self.padding_width = 1 self.left_padding_width = 1 self.right_padding_width = 1 self.vertical_char = \"|\" def _set_columns_style(self): self.header = True self.border = False self.padding_width = 1 self.left_padding_width = 0 self.right_padding_width = 8 def _set_random_style(self): # Just for fun! self.header = random.choice((True, False)) self.border = random.choice((True, False)) self._hrules = random.choice((ALL, FRAME, HEADER, NONE)) self._vrules = random.choice((ALL, FRAME, NONE)) self.left_padding_width = random.randint(0, 5) self.right_padding_width = random.randint(0, 5) self.vertical_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") self.horizontal_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") self.junction_char = random.choice(r\"~!@#$%^&*()_+|-=\\{}[];':\\\",./;<>?\") ############################## # DATA INPUT METHODS # ############################## def add_row(self, row): \"\"\"Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields\"\"\" if self._field_names and len(row) != len(self._field_names): raise Exception( \"Row has incorrect number of values, (actual) %d!=%d (expected)\" % (len(row), len(self._field_names)) ) if not self._field_names: self.field_names = [(\"Field %d\" % (n + 1)) for n in range(0, len(row))] self._rows.append(list(row)) def del_row(self, row_index): \"\"\"Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0.\"\"\" if row_index > len(self._rows) - 1: raise Exception( \"Cant delete row at index %d, table only has %d rows!\" % (row_index, len(self._rows)) ) del self._rows[row_index] def add_column(self, fieldname, column, align=\"c\", valign=\"t\"): \"\"\"Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom\"\"\" if len(self._rows) in (0, len(column)): self._validate_align(align) self._validate_valign(valign) self._field_names.append(fieldname) self._align[fieldname] = align self._valign[fieldname] = valign for i in range(0, len(column)): if len(self._rows) < i + 1: self._rows.append([]) self._rows[i].append(column[i]) else: raise Exception( \"Column length %d does not match number of rows %d!\" % (len(column), len(self._rows)) ) def clear_rows(self): \"\"\"Delete all rows from the table but keep the current field names\"\"\" self._rows = [] def clear(self): \"\"\"Delete all rows and field names from the table, maintaining nothing but styling options\"\"\" self._rows = [] self._field_names = [] self._widths = [] ############################## # MISC PUBLIC METHODS # ############################## def copy(self): return copy.deepcopy(self) ############################## # MISC PRIVATE METHODS # ############################## def _format_value(self, field, value): if isinstance(value, int) and field in self._int_format: value = self._unicode((\"%%%sd\" % self._int_format[field]) % value) elif isinstance(value, float) and field in self._float_format: value = self._unicode((\"%%%sf\" % self._float_format[field]) % value) return self._unicode(value) def _compute_table_width(self, options): table_width = 2 if options[\"vrules\"] in (FRAME, ALL) else 0 per_col_padding = sum(self._get_padding_widths(options)) for index, fieldname in enumerate(self.field_names): if not options[\"fields\"] or ( options[\"fields\"] and fieldname in options[\"fields\"] ): table_width += self._widths[index] + per_col_padding return table_width def _compute_widths(self, rows, options): if options[\"header\"]: widths = [_get_size(field)[0] for field in self._field_names] else: widths = len(self.field_names) * [0] for row in rows: for index, value in enumerate(row): fieldname = self.field_names[index] if fieldname in self.max_width: widths[index] = max( widths[index], min(_get_size(value)[0], self.max_width[fieldname]), ) else: widths[index] = max(widths[index], _get_size(value)[0]) if fieldname in self.min_width: widths[index] = max(widths[index], self.min_width[fieldname]) self._widths = widths # Are we exceeding max_table_width? if self._max_table_width: table_width = self._compute_table_width(options) if table_width > self._max_table_width: # Shrink widths in proportion scale = 1.0 * self._max_table_width / table_width widths = [int(math.floor(w * scale)) for w in widths] self._widths = widths # Are we under min_table_width or title width? if self._min_table_width or options[\"title\"]: if options[\"title\"]: title_width = len(options[\"title\"]) + sum( self._get_padding_widths(options) ) if options[\"vrules\"] in (FRAME, ALL): title_width += 2 else: title_width = 0 min_table_width = self.min_table_width or 0 min_width = max(title_width, min_table_width) table_width = self._compute_table_width(options) if table_width < min_width: # Grow widths in proportion scale = 1.0 * min_width / table_width widths = [int(math.ceil(w * scale)) for w in widths] self._widths = widths def _get_padding_widths(self, options): if options[\"left_padding_width\"] is not None: lpad = options[\"left_padding_width\"] else: lpad = options[\"padding_width\"] if options[\"right_padding_width\"] is not None: rpad = options[\"right_padding_width\"] else: rpad = options[\"padding_width\"] return lpad, rpad def _get_rows(self, options): \"\"\"Return only those data rows that should be printed, based on slicing and sorting. Arguments: options - dictionary of option settings.\"\"\" if options[\"oldsortslice\"]: rows = copy.deepcopy(self._rows[options[\"start\"] : options[\"end\"]]) else: rows = copy.deepcopy(self._rows) # Sort if options[\"sortby\"]: sortindex = self._field_names.index(options[\"sortby\"]) # Decorate rows = [[row[sortindex]] + row for row in rows] # Sort rows.sort(reverse=options[\"reversesort\"], key=options[\"sort_key\"]) # Undecorate rows = [row[1:] for row in rows] # Slice if necessary if not options[\"oldsortslice\"]: rows = rows[options[\"start\"] : options[\"end\"]] return rows def _format_row(self, row, options): return [ self._format_value(field, value) for (field, value) in zip(self._field_names, row) ] def _format_rows(self, rows, options): return [self._format_row(row, options) for row in rows] ############################## # PLAIN TEXT STRING METHODS # ############################## def get_string(self, **kwargs): \"\"\"Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string \"\"\" options = self._get_options(kwargs) lines = [] # Don't think too hard about an empty table # Is this the desired behaviour? Maybe we should still print the header? if self.rowcount == 0 and (not options[\"print_empty\"] or not options[\"border\"]): return \"\" # Get the rows we need to print, taking into account slicing, sorting, etc. rows = self._get_rows(options) # Turn all data in all rows into Unicode, formatted as desired formatted_rows = self._format_rows(rows, options) # Compute column widths self._compute_widths(formatted_rows, options) self._hrule = self._stringify_hrule(options) # Add title title = options[\"title\"] or self._title if title: lines.append(self._stringify_title(title, options)) # Add header or top of border if options[\"header\"]: lines.append(self._stringify_header(options)) elif options[\"border\"] and options[\"hrules\"] in (ALL, FRAME): lines.append(self._hrule) # Add rows for row in formatted_rows: lines.append(self._stringify_row(row, options)) # Add bottom of border if options[\"border\"] and options[\"hrules\"] == FRAME: lines.append(self._hrule) return self._unicode(\"\\n\").join(lines) def _stringify_hrule(self, options): if not options[\"border\"]: return \"\" lpad, rpad = self._get_padding_widths(options) if options[\"vrules\"] in (ALL, FRAME): bits = [options[\"junction_char\"]] else: bits = [options[\"horizontal_char\"]] # For tables with no data or fieldnames if not self._field_names: bits.append(options[\"junction_char\"]) return \"\".join(bits) for field, width in zip(self._field_names, self._widths): if options[\"fields\"] and field not in options[\"fields\"]: continue bits.append((width + lpad + rpad) * options[\"horizontal_char\"]) if options[\"vrules\"] == ALL: bits.append(options[\"junction_char\"]) else: bits.append(options[\"horizontal_char\"]) if options[\"vrules\"] == FRAME: bits.pop() bits.append(options[\"junction_char\"]) return \"\".join(bits) def _stringify_title(self, title, options): lines = [] lpad, rpad = self._get_padding_widths(options) if options[\"border\"]: if options[\"vrules\"] == ALL: options[\"vrules\"] = FRAME lines.append(self._stringify_hrule(options)) options[\"vrules\"] = ALL elif options[\"vrules\"] == FRAME: lines.append(self._stringify_hrule(options)) bits = [] endpoint = ( options[\"vertical_char\"] if options[\"vrules\"] in (ALL, FRAME) else \" \" ) bits.append(endpoint) title = \" \" * lpad + title + \" \" * rpad bits.append(self._justify(title, len(self._hrule) - 2, \"c\")) bits.append(endpoint) lines.append(\"\".join(bits)) return \"\\n\".join(lines) def _stringify_header(self, options): bits = [] lpad, rpad = self._get_padding_widths(options) if options[\"border\"]: if options[\"hrules\"] in (ALL, FRAME): bits.append(self._hrule) bits.append(\"\\n\") if options[\"vrules\"] in (ALL, FRAME): bits.append(options[\"vertical_char\"]) else: bits.append(\" \") # For tables with no data or field names if not self._field_names: if options[\"vrules\"] in (ALL, FRAME): bits.append(options[\"vertical_char\"]) else: bits.append(\" \") for field, width, in zip(self._field_names, self._widths): if options[\"fields\"] and field not in options[\"fields\"]: continue if self._header_style == \"cap\": fieldname = field.capitalize() elif self._header_style == \"title\": fieldname = field.title() elif self._header_style == \"upper\": fieldname = field.upper() elif self._header_style == \"lower\": fieldname = field.lower() else: fieldname = field bits.append( \" \" * lpad + self._justify(fieldname, width, self._align[field]) + \" \" * rpad ) if options[\"border\"]: if options[\"vrules\"] == ALL: bits.append(options[\"vertical_char\"]) else: bits.append(\" \") # If vrules is FRAME, then we just appended a space at the end # of the last field, when we really want a vertical character if options[\"border\"] and options[\"vrules\"] == FRAME: bits.pop() bits.append(options[\"vertical_char\"]) if options[\"border\"] and options[\"hrules\"] != NONE: bits.append(\"\\n\") bits.append(self._hrule) return \"\".join(bits) def _stringify_row(self, row, options): for index, field, value, width, in zip( range(0, len(row)), self._field_names, row, self._widths ): # Enforce max widths lines = value.split(\"\\n\") new_lines = [] for line in lines: if _str_block_width(line) > width: line = textwrap.fill(line, width) new_lines.append(line) lines = new_lines value = \"\\n\".join(lines) row[index] = value row_height = 0 for c in row: h = _get_size(c)[1] if h > row_height: row_height = h bits = [] lpad, rpad = self._get_padding_widths(options) for y in range(0, row_height): bits.append([]) if options[\"border\"]: if options[\"vrules\"] in (ALL, FRAME): bits[y].append(self.vertical_char) else: bits[y].append(\" \") for field, value, width, in zip(self._field_names, row, self._widths): valign = self._valign[field] lines = value.split(\"\\n\") dHeight = row_height - len(lines) if dHeight: if valign == \"m\": lines = ( [\"\"] * int(dHeight / 2) + lines + [\"\"] * (dHeight - int(dHeight / 2)) ) elif valign == \"b\": lines = [\"\"] * dHeight + lines else: lines = lines + [\"\"] * dHeight y = 0 for l in lines: if options[\"fields\"] and field not in options[\"fields\"]: continue bits[y].append( \" \" * lpad + self._justify(l, width, self._align[field]) + \" \" * rpad ) if options[\"border\"]: if options[\"vrules\"] == ALL: bits[y].append(self.vertical_char) else: bits[y].append(\" \") y += 1 # If vrules is FRAME, then we just appended a space at the end # of the last field, when we really want a vertical character for y in range(0, row_height): if options[\"border\"] and options[\"vrules\"] == FRAME: bits[y].pop() bits[y].append(options[\"vertical_char\"]) if options[\"border\"] and options[\"hrules\"] == ALL: bits[row_height - 1].append(\"\\n\") bits[row_height - 1].append(self._hrule) for y in range(0, row_height): bits[y] = \"\".join(bits[y]) return \"\\n\".join(bits) def paginate(self, page_length=58, **kwargs): pages = [] kwargs[\"start\"] = kwargs.get(\"start\", 0) true_end = kwargs.get(\"end\", self.rowcount) while True: kwargs[\"end\"] = min(kwargs[\"start\"] + page_length, true_end) pages.append(self.get_string(**kwargs)) if kwargs[\"end\"] == true_end: break kwargs[\"start\"] += page_length return \"\\f\".join(pages) ############################## # JSON STRING METHODS # ############################## def get_json_string(self, **kwargs): \"\"\"Return string representation of JSON formatted table in the current state Arguments: none yet\"\"\" options = self._get_options(kwargs) objects = [self.field_names] for row in self._get_rows(options): objects.append(dict(zip(self._field_names, row))) return json.dumps(objects, indent=4, separators=(\",\", \": \"), sort_keys=True) ############################## # HTML STRING METHODS # ############################## def get_html_string(self, **kwargs): \"\"\"Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag xhtml - print <br/> tags if True, <br> tags if false\"\"\" options = self._get_options(kwargs) if options[\"format\"]: string = self._get_formatted_html_string(options) else: string = self._get_simple_html_string(options) return string def _get_simple_html_string(self, options): lines = [] if options[\"xhtml\"]: linebreak = \"<br/>\" else: linebreak = \"<br>\" open_tag = [\"<table\"] if options[\"attributes\"]: for attr_name in options[\"attributes\"]: open_tag.append( ' {}=\"{}\"'.format(attr_name, options[\"attributes\"][attr_name]) ) open_tag.append(\">\") lines.append(\"\".join(open_tag)) # Title title = options[\"title\"] or self._title if title: cols = ( len(options[\"fields\"]) if options[\"fields\"] else len(self.field_names) ) lines.append(\" <tr>\") lines.append(\" <td colspan=%d>%s</td>\" % (cols, title)) lines.append(\" </tr>\") # Headers if options[\"header\"]: lines.append(\" <tr>\") for field in self._field_names: if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( \" <th>%s</th>\" % escape(field).replace(\"\\n\", linebreak) ) lines.append(\" </tr>\") # Data rows = self._get_rows(options) formatted_rows = self._format_rows(rows, options) for row in formatted_rows: lines.append(\" <tr>\") for field, datum in zip(self._field_names, row): if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( \" <td>%s</td>\" % escape(datum).replace(\"\\n\", linebreak) ) lines.append(\" </tr>\") lines.append(\"</table>\") return self._unicode(\"\\n\").join(lines) def _get_formatted_html_string(self, options): lines = [] lpad, rpad = self._get_padding_widths(options) if options[\"xhtml\"]: linebreak = \"<br/>\" else: linebreak = \"<br>\" open_tag = [\"<table\"] if options[\"border\"]: if options[\"hrules\"] == ALL and options[\"vrules\"] == ALL: open_tag.append(' frame=\"box\" rules=\"all\"') elif options[\"hrules\"] == FRAME and options[\"vrules\"] == FRAME: open_tag.append(' frame=\"box\"') elif options[\"hrules\"] == FRAME and options[\"vrules\"] == ALL: open_tag.append(' frame=\"box\" rules=\"cols\"') elif options[\"hrules\"] == FRAME: open_tag.append(' frame=\"hsides\"') elif options[\"hrules\"] == ALL: open_tag.append(' frame=\"hsides\" rules=\"rows\"') elif options[\"vrules\"] == FRAME: open_tag.append(' frame=\"vsides\"') elif options[\"vrules\"] == ALL: open_tag.append(' frame=\"vsides\" rules=\"cols\"') if options[\"attributes\"]: for attr_name in options[\"attributes\"]: open_tag.append( ' {}=\"{}\"'.format(attr_name, options[\"attributes\"][attr_name]) ) open_tag.append(\">\") lines.append(\"\".join(open_tag)) # Title title = options[\"title\"] or self._title if title: cols = ( len(options[\"fields\"]) if options[\"fields\"] else len(self.field_names) ) lines.append(\" <tr>\") lines.append(\" <td colspan=%d>%s</td>\" % (cols, title)) lines.append(\" </tr>\") # Headers if options[\"header\"]: lines.append(\" <tr>\") for field in self._field_names: if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( ' <th style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</th>' # noqa: E501 % (lpad, rpad, escape(field).replace(\"\\n\", linebreak)) ) lines.append(\" </tr>\") # Data rows = self._get_rows(options) formatted_rows = self._format_rows(rows, options) aligns = [] valigns = [] for field in self._field_names: aligns.append( {\"l\": \"left\", \"r\": \"right\", \"c\": \"center\"}[self._align[field]] ) valigns.append( {\"t\": \"top\", \"m\": \"middle\", \"b\": \"bottom\"}[self._valign[field]] ) for row in formatted_rows: lines.append(\" <tr>\") for field, datum, align, valign in zip( self._field_names, row, aligns, valigns ): if options[\"fields\"] and field not in options[\"fields\"]: continue lines.append( ' <td style=\"padding-left: %dem; padding-right: %dem; text-align: %s; vertical-align: %s\">%s</td>' # noqa: E501 % ( lpad, rpad, align, valign, escape(datum).replace(\"\\n\", linebreak), ) ) lines.append(\" </tr>\") lines.append(\"</table>\") return self._unicode(\"\\n\").join(lines)","title":"PrettyTable"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.align","text":"Controls alignment of fields Arguments: align - alignment, one of \"l\", \"c\", or \"r\"","title":"align"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.attributes","text":"A dictionary of HTML attribute name/value pairs to be included in the tag when printing HTML Arguments: attributes - dictionary of attributes","title":"attributes"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.border","text":"Controls printing of border around table Arguments: border - print a border around the table (True or False)","title":"border"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.end","text":"End index of the range of rows to print Arguments: end - index of last data row to include in output PLUS ONE (list slice style)","title":"end"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.field_names","text":"List or tuple of field names","title":"field_names"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.fields","text":"List or tuple of field names to include in displays","title":"fields"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.float_format","text":"Controls formatting of floating point data Arguments: float_format - floating point format string","title":"float_format"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.format","text":"Controls whether or not HTML tables are formatted to match styling options Arguments: format - True or False","title":"format"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.header","text":"Controls printing of table header with field names Arguments: header - print a header showing field names (True or False)","title":"header"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.header_style","text":"Controls stylisation applied to field names in header Arguments: header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None)","title":"header_style"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.horizontal_char","text":"The charcter used when printing table borders to draw horizontal lines Arguments: horizontal_char - single character string used to draw horizontal lines","title":"horizontal_char"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.hrules","text":"Controls printing of horizontal rules after rows Arguments: hrules - horizontal rules style. Allowed values: FRAME, ALL, HEADER, NONE","title":"hrules"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.int_format","text":"Controls formatting of integer data Arguments: int_format - integer format string","title":"int_format"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.junction_char","text":"The charcter used when printing table borders to draw line junctions Arguments: junction_char - single character string used to draw line junctions","title":"junction_char"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.left_padding_width","text":"The number of empty spaces between a column's left edge and its content Arguments: left_padding - number of spaces, must be a positive integer","title":"left_padding_width"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.max_width","text":"Controls maximum width of fields Arguments: max_width - maximum width integer","title":"max_width"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.min_width","text":"Controls minimum width of fields Arguments: min_width - minimum width integer","title":"min_width"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.oldsortslice","text":"oldsortslice - Slice rows before sorting in the \"old style\"","title":"oldsortslice"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.padding_width","text":"The number of empty spaces between a column's edge and its content Arguments: padding_width - number of spaces, must be a positive integer","title":"padding_width"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.print_empty","text":"Controls whether or not empty tables produce a header and frame or just an empty string Arguments: print_empty - True or False","title":"print_empty"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.reversesort","text":"Controls direction of sorting (ascending vs descending) Arguments: reveresort - set to True to sort by descending order, or False to sort by ascending order","title":"reversesort"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.right_padding_width","text":"The number of empty spaces between a column's right edge and its content Arguments: right_padding - number of spaces, must be a positive integer","title":"right_padding_width"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.sort_key","text":"Sorting key function, applied to data points before sorting Arguments: sort_key - a function which takes one argument and returns something to be sorted","title":"sort_key"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.sortby","text":"Name of field by which to sort rows Arguments: sortby - field name to sort by","title":"sortby"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.start","text":"Start index of the range of rows to print Arguments: start - index of first data row to include in output","title":"start"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.title","text":"Optional table title Arguments: title - table title","title":"title"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.valign","text":"Controls vertical alignment of fields Arguments: valign - vertical alignment, one of \"t\", \"m\", or \"b\"","title":"valign"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.vertical_char","text":"The charcter used when printing table borders to draw vertical lines Arguments: vertical_char - single character string used to draw vertical lines","title":"vertical_char"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.vrules","text":"Controls printing of vertical rules between columns Arguments: vrules - vertical rules style. Allowed values: FRAME, ALL, NONE","title":"vrules"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.__init__","text":"Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" Source code in chispa/prettytable.py def __init__(self, field_names=None, **kwargs): \"\"\"Return a new PrettyTable instance Arguments: encoding - Unicode encoding scheme used to decode any encoded input title - optional table title field_names - list or tuple of field names fields - list or tuple of field names to include in displays start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) header - print a header showing field names (True or False) header_style - stylisation to apply to field names in header (\"cap\", \"title\", \"upper\", \"lower\" or None) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: FRAME, HEADER, ALL, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data min_table_width - minimum desired table width, in characters max_table_width - maximum desired table width, in characters padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting valign - default valign for each row (None, \"t\", \"m\" or \"b\") reversesort - True or False to sort in descending or ascending order oldsortslice - Slice rows before sorting in the \"old style\" \"\"\" self.encoding = kwargs.get(\"encoding\", \"UTF-8\") # Data self._field_names = [] self._rows = [] self.align = {} self.valign = {} self.max_width = {} self.min_width = {} self.int_format = {} self.float_format = {} if field_names: self.field_names = field_names else: self._widths = [] # Options self._options = ( \"title start end fields header border sortby reversesort \" \"sort_key attributes format hrules vrules\".split() ) self._options.extend( \"int_format float_format min_table_width max_table_width padding_width \" \"left_padding_width right_padding_width\".split() ) self._options.extend( \"vertical_char horizontal_char junction_char header_style valign xhtml \" \"print_empty oldsortslice\".split() ) self._options.extend(\"align valign max_width min_width\".split()) for option in self._options: if option in kwargs: self._validate_option(option, kwargs[option]) else: kwargs[option] = None self._title = kwargs[\"title\"] or None self._start = kwargs[\"start\"] or 0 self._end = kwargs[\"end\"] or None self._fields = kwargs[\"fields\"] or None if kwargs[\"header\"] in (True, False): self._header = kwargs[\"header\"] else: self._header = True self._header_style = kwargs[\"header_style\"] or None if kwargs[\"border\"] in (True, False): self._border = kwargs[\"border\"] else: self._border = True self._hrules = kwargs[\"hrules\"] or FRAME self._vrules = kwargs[\"vrules\"] or ALL self._sortby = kwargs[\"sortby\"] or None if kwargs[\"reversesort\"] in (True, False): self._reversesort = kwargs[\"reversesort\"] else: self._reversesort = False self._sort_key = kwargs[\"sort_key\"] or (lambda x: x) # Column specific arguments, use property.setters self.align = kwargs[\"align\"] or {} self.valign = kwargs[\"valign\"] or {} self.max_width = kwargs[\"max_width\"] or {} self.min_width = kwargs[\"min_width\"] or {} self.int_format = kwargs[\"int_format\"] or {} self.float_format = kwargs[\"float_format\"] or {} self._min_table_width = kwargs[\"min_table_width\"] or None self._max_table_width = kwargs[\"max_table_width\"] or None self._padding_width = kwargs[\"padding_width\"] or 1 self._left_padding_width = kwargs[\"left_padding_width\"] or None self._right_padding_width = kwargs[\"right_padding_width\"] or None self._vertical_char = kwargs[\"vertical_char\"] or self._unicode(\"|\") self._horizontal_char = kwargs[\"horizontal_char\"] or self._unicode(\"-\") self._junction_char = kwargs[\"junction_char\"] or self._unicode(\"+\") if kwargs[\"print_empty\"] in (True, False): self._print_empty = kwargs[\"print_empty\"] else: self._print_empty = True if kwargs[\"oldsortslice\"] in (True, False): self._oldsortslice = kwargs[\"oldsortslice\"] else: self._oldsortslice = False self._format = kwargs[\"format\"] or False self._xhtml = kwargs[\"xhtml\"] or False self._attributes = kwargs[\"attributes\"] or {}","title":"__init__()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.add_column","text":"Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom Source code in chispa/prettytable.py def add_column(self, fieldname, column, align=\"c\", valign=\"t\"): \"\"\"Add a column to the table. Arguments: fieldname - name of the field to contain the new column of data column - column of data, should be a list with as many elements as the table has rows align - desired alignment for this column - \"l\" for left, \"c\" for centre and \"r\" for right valign - desired vertical alignment for new columns - \"t\" for top, \"m\" for middle and \"b\" for bottom\"\"\" if len(self._rows) in (0, len(column)): self._validate_align(align) self._validate_valign(valign) self._field_names.append(fieldname) self._align[fieldname] = align self._valign[fieldname] = valign for i in range(0, len(column)): if len(self._rows) < i + 1: self._rows.append([]) self._rows[i].append(column[i]) else: raise Exception( \"Column length %d does not match number of rows %d!\" % (len(column), len(self._rows)) )","title":"add_column()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.add_row","text":"Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields Source code in chispa/prettytable.py def add_row(self, row): \"\"\"Add a row to the table Arguments: row - row of data, should be a list with as many elements as the table has fields\"\"\" if self._field_names and len(row) != len(self._field_names): raise Exception( \"Row has incorrect number of values, (actual) %d!=%d (expected)\" % (len(row), len(self._field_names)) ) if not self._field_names: self.field_names = [(\"Field %d\" % (n + 1)) for n in range(0, len(row))] self._rows.append(list(row))","title":"add_row()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.clear","text":"Delete all rows and field names from the table, maintaining nothing but styling options Source code in chispa/prettytable.py def clear(self): \"\"\"Delete all rows and field names from the table, maintaining nothing but styling options\"\"\" self._rows = [] self._field_names = [] self._widths = []","title":"clear()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.clear_rows","text":"Delete all rows from the table but keep the current field names Source code in chispa/prettytable.py def clear_rows(self): \"\"\"Delete all rows from the table but keep the current field names\"\"\" self._rows = []","title":"clear_rows()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.del_row","text":"Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0. Source code in chispa/prettytable.py def del_row(self, row_index): \"\"\"Delete a row to the table Arguments: row_index - The index of the row you want to delete. Indexing starts at 0.\"\"\" if row_index > len(self._rows) - 1: raise Exception( \"Cant delete row at index %d, table only has %d rows!\" % (row_index, len(self._rows)) ) del self._rows[row_index]","title":"del_row()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.get_html_string","text":"Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the tag xhtml - print tags if True, tags if false Source code in chispa/prettytable.py def get_html_string(self, **kwargs): \"\"\"Return string representation of HTML formatted version of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag xhtml - print <br/> tags if True, <br> tags if false\"\"\" options = self._get_options(kwargs) if options[\"format\"]: string = self._get_formatted_html_string(options) else: string = self._get_simple_html_string(options) return string","title":"get_html_string()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.get_json_string","text":"Return string representation of JSON formatted table in the current state Arguments: none yet Source code in chispa/prettytable.py def get_json_string(self, **kwargs): \"\"\"Return string representation of JSON formatted table in the current state Arguments: none yet\"\"\" options = self._get_options(kwargs) objects = [self.field_names] for row in self._get_rows(options): objects.append(dict(zip(self._field_names, row))) return json.dumps(objects, indent=4, separators=(\",\", \": \"), sort_keys=True)","title":"get_json_string()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.PrettyTable.get_string","text":"Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string Source code in chispa/prettytable.py def get_string(self, **kwargs): \"\"\"Return string representation of table in current state. Arguments: title - optional table title start - index of first data row to include in output end - index of last data row to include in output PLUS ONE (list slice style) fields - names of fields (columns) to include header - print a header showing field names (True or False) border - print a border around the table (True or False) hrules - controls printing of horizontal rules after rows. Allowed values: ALL, FRAME, HEADER, NONE vrules - controls printing of vertical rules between columns. Allowed values: FRAME, ALL, NONE int_format - controls formatting of integer data float_format - controls formatting of floating point data padding_width - number of spaces on either side of column data (only used if left and right paddings are None) left_padding_width - number of spaces on left hand side of column data right_padding_width - number of spaces on right hand side of column data vertical_char - single character string used to draw vertical lines horizontal_char - single character string used to draw horizontal lines junction_char - single character string used to draw line junctions sortby - name of field to sort rows by sort_key - sorting key function, applied to data points before sorting reversesort - True or False to sort in descending or ascending order print empty - if True, stringify just the header for an empty table, if False return an empty string \"\"\" options = self._get_options(kwargs) lines = [] # Don't think too hard about an empty table # Is this the desired behaviour? Maybe we should still print the header? if self.rowcount == 0 and (not options[\"print_empty\"] or not options[\"border\"]): return \"\" # Get the rows we need to print, taking into account slicing, sorting, etc. rows = self._get_rows(options) # Turn all data in all rows into Unicode, formatted as desired formatted_rows = self._format_rows(rows, options) # Compute column widths self._compute_widths(formatted_rows, options) self._hrule = self._stringify_hrule(options) # Add title title = options[\"title\"] or self._title if title: lines.append(self._stringify_title(title, options)) # Add header or top of border if options[\"header\"]: lines.append(self._stringify_header(options)) elif options[\"border\"] and options[\"hrules\"] in (ALL, FRAME): lines.append(self._hrule) # Add rows for row in formatted_rows: lines.append(self._stringify_row(row, options)) # Add bottom of border if options[\"border\"] and options[\"hrules\"] == FRAME: lines.append(self._hrule) return self._unicode(\"\\n\").join(lines)","title":"get_string()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.TableHandler","text":"Bases: HTMLParser Source code in chispa/prettytable.py class TableHandler(HTMLParser): def __init__(self, **kwargs): HTMLParser.__init__(self) self.kwargs = kwargs self.tables = [] self.last_row = [] self.rows = [] self.max_row_width = 0 self.active = None self.last_content = \"\" self.is_last_row_header = False self.colspan = 0 def handle_starttag(self, tag, attrs): self.active = tag if tag == \"th\": self.is_last_row_header = True for (key, value) in attrs: if key == \"colspan\": self.colspan = int(value) def handle_endtag(self, tag): if tag in [\"th\", \"td\"]: stripped_content = self.last_content.strip() self.last_row.append(stripped_content) if self.colspan: for i in range(1, self.colspan): self.last_row.append(\"\") self.colspan = 0 if tag == \"tr\": self.rows.append((self.last_row, self.is_last_row_header)) self.max_row_width = max(self.max_row_width, len(self.last_row)) self.last_row = [] self.is_last_row_header = False if tag == \"table\": table = self.generate_table(self.rows) self.tables.append(table) self.rows = [] self.last_content = \" \" self.active = None def handle_data(self, data): self.last_content += data def generate_table(self, rows): \"\"\" Generates from a list of rows a PrettyTable object. \"\"\" table = PrettyTable(**self.kwargs) for row in self.rows: if len(row[0]) < self.max_row_width: appends = self.max_row_width - len(row[0]) for i in range(1, appends): row[0].append(\"-\") if row[1]: self.make_fields_unique(row[0]) table.field_names = row[0] else: table.add_row(row[0]) return table def make_fields_unique(self, fields): \"\"\" iterates over the row and make each field unique \"\"\" for i in range(0, len(fields)): for j in range(i + 1, len(fields)): if fields[i] == fields[j]: fields[j] += \"'\"","title":"TableHandler"},{"location":"reference/chispa/prettytable/#chispa.prettytable.TableHandler.generate_table","text":"Generates from a list of rows a PrettyTable object. Source code in chispa/prettytable.py def generate_table(self, rows): \"\"\" Generates from a list of rows a PrettyTable object. \"\"\" table = PrettyTable(**self.kwargs) for row in self.rows: if len(row[0]) < self.max_row_width: appends = self.max_row_width - len(row[0]) for i in range(1, appends): row[0].append(\"-\") if row[1]: self.make_fields_unique(row[0]) table.field_names = row[0] else: table.add_row(row[0]) return table","title":"generate_table()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.TableHandler.make_fields_unique","text":"iterates over the row and make each field unique Source code in chispa/prettytable.py def make_fields_unique(self, fields): \"\"\" iterates over the row and make each field unique \"\"\" for i in range(0, len(fields)): for j in range(i + 1, len(fields)): if fields[i] == fields[j]: fields[j] += \"'\"","title":"make_fields_unique()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.from_html","text":"Generates a list of PrettyTables from a string of HTML code. Each in the HTML becomes one PrettyTable object. Source code in chispa/prettytable.py def from_html(html_code, **kwargs): \"\"\" Generates a list of PrettyTables from a string of HTML code. Each <table> in the HTML becomes one PrettyTable object. \"\"\" parser = TableHandler(**kwargs) parser.feed(html_code) return parser.tables","title":"from_html()"},{"location":"reference/chispa/prettytable/#chispa.prettytable.from_html_one","text":"Generates a PrettyTables from a string of HTML code which contains only a single Source code in chispa/prettytable.py def from_html_one(html_code, **kwargs): \"\"\" Generates a PrettyTables from a string of HTML code which contains only a single <table> \"\"\" tables = from_html(html_code, **kwargs) try: assert len(tables) == 1 except AssertionError: raise Exception( \"More than one <table> in provided HTML code! Use from_html instead.\" ) return tables[0]","title":"from_html_one()"},{"location":"reference/chispa/row_comparer/","text":"","title":"Row comparer"},{"location":"reference/chispa/rows_comparer/","text":"","title":"Rows comparer"},{"location":"reference/chispa/schema_comparer/","text":"SchemasNotEqualError Bases: Exception The schemas are not equal Source code in chispa/schema_comparer.py class SchemasNotEqualError(Exception): \"\"\"The schemas are not equal\"\"\" pass are_datatypes_equal_ignore_nullable(dt1, dt2) Checks if datatypes are equal, descending into structs and arrays to ignore nullability. Source code in chispa/schema_comparer.py def are_datatypes_equal_ignore_nullable(dt1, dt2): \"\"\"Checks if datatypes are equal, descending into structs and arrays to ignore nullability. \"\"\" if dt1.typeName() == dt2.typeName(): # Account for array types by inspecting elementType. if dt1.typeName() == 'array': return are_datatypes_equal_ignore_nullable(dt1.elementType, dt2.elementType) elif dt1.typeName() == 'struct': return are_schemas_equal_ignore_nullable(dt1, dt2) else: return True else: return False","title":"Schema comparer"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.SchemasNotEqualError","text":"Bases: Exception The schemas are not equal Source code in chispa/schema_comparer.py class SchemasNotEqualError(Exception): \"\"\"The schemas are not equal\"\"\" pass","title":"SchemasNotEqualError"},{"location":"reference/chispa/schema_comparer/#chispa.schema_comparer.are_datatypes_equal_ignore_nullable","text":"Checks if datatypes are equal, descending into structs and arrays to ignore nullability. Source code in chispa/schema_comparer.py def are_datatypes_equal_ignore_nullable(dt1, dt2): \"\"\"Checks if datatypes are equal, descending into structs and arrays to ignore nullability. \"\"\" if dt1.typeName() == dt2.typeName(): # Account for array types by inspecting elementType. if dt1.typeName() == 'array': return are_datatypes_equal_ignore_nullable(dt1.elementType, dt2.elementType) elif dt1.typeName() == 'struct': return are_schemas_equal_ignore_nullable(dt1, dt2) else: return True else: return False","title":"are_datatypes_equal_ignore_nullable()"},{"location":"reference/chispa/six/","text":"Utilities for writing code that runs on Python 2 and 3 Module_six_moves_urllib Bases: types . ModuleType Create a six.moves.urllib namespace that resembles the Python 3 namespace Source code in chispa/six.py class Module_six_moves_urllib(types.ModuleType): \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\" __path__ = [] # mark as package parse = _importer._get_module(\"moves.urllib_parse\") error = _importer._get_module(\"moves.urllib_error\") request = _importer._get_module(\"moves.urllib_request\") response = _importer._get_module(\"moves.urllib_response\") robotparser = _importer._get_module(\"moves.urllib_robotparser\") def __dir__(self): return ['parse', 'error', 'request', 'response', 'robotparser'] Module_six_moves_urllib_error Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_error Source code in chispa/six.py class Module_six_moves_urllib_error(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\" Module_six_moves_urllib_parse Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_parse Source code in chispa/six.py class Module_six_moves_urllib_parse(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\" Module_six_moves_urllib_request Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_request Source code in chispa/six.py class Module_six_moves_urllib_request(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\" Module_six_moves_urllib_response Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_response Source code in chispa/six.py class Module_six_moves_urllib_response(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\" Module_six_moves_urllib_robotparser Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_robotparser Source code in chispa/six.py class Module_six_moves_urllib_robotparser(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\" add_metaclass(metaclass) Class decorator for creating a class with a metaclass. Source code in chispa/six.py def add_metaclass(metaclass): \"\"\"Class decorator for creating a class with a metaclass.\"\"\" def wrapper(cls): orig_vars = cls.__dict__.copy() slots = orig_vars.get('__slots__') if slots is not None: if isinstance(slots, str): slots = [slots] for slots_var in slots: orig_vars.pop(slots_var) orig_vars.pop('__dict__', None) orig_vars.pop('__weakref__', None) if hasattr(cls, '__qualname__'): orig_vars['__qualname__'] = cls.__qualname__ return metaclass(cls.__name__, cls.__bases__, orig_vars) return wrapper add_move(move) Add an item to six.moves. Source code in chispa/six.py def add_move(move): \"\"\"Add an item to six.moves.\"\"\" setattr(_MovedItems, move.name, move) ensure_binary(s, encoding='utf-8', errors='strict') Coerce s to six.binary_type. For Python 2: - unicode -> encoded to str - str -> str For Python 3: - str -> encoded to bytes - bytes -> bytes Source code in chispa/six.py def ensure_binary(s, encoding='utf-8', errors='strict'): \"\"\"Coerce **s** to six.binary_type. For Python 2: - `unicode` -> encoded to `str` - `str` -> `str` For Python 3: - `str` -> encoded to `bytes` - `bytes` -> `bytes` \"\"\" if isinstance(s, binary_type): return s if isinstance(s, text_type): return s.encode(encoding, errors) raise TypeError(\"not expecting type '%s'\" % type(s)) ensure_str(s, encoding='utf-8', errors='strict') Coerce s to str . For Python 2: - unicode -> encoded to str - str -> str For Python 3: - str -> str - bytes -> decoded to str Source code in chispa/six.py def ensure_str(s, encoding='utf-8', errors='strict'): \"\"\"Coerce *s* to `str`. For Python 2: - `unicode` -> encoded to `str` - `str` -> `str` For Python 3: - `str` -> `str` - `bytes` -> decoded to `str` \"\"\" # Optimization: Fast return for the common case. if type(s) is str: return s if PY2 and isinstance(s, text_type): return s.encode(encoding, errors) elif PY3 and isinstance(s, binary_type): return s.decode(encoding, errors) elif not isinstance(s, (text_type, binary_type)): raise TypeError(\"not expecting type '%s'\" % type(s)) return s ensure_text(s, encoding='utf-8', errors='strict') Coerce s to six.text_type. For Python 2: - unicode -> unicode - str -> unicode For Python 3: - str -> str - bytes -> decoded to str Source code in chispa/six.py def ensure_text(s, encoding='utf-8', errors='strict'): \"\"\"Coerce *s* to six.text_type. For Python 2: - `unicode` -> `unicode` - `str` -> `unicode` For Python 3: - `str` -> `str` - `bytes` -> decoded to `str` \"\"\" if isinstance(s, binary_type): return s.decode(encoding, errors) elif isinstance(s, text_type): return s else: raise TypeError(\"not expecting type '%s'\" % type(s)) exec_(_code_, _globs_=None, _locs_=None) Execute code in a namespace. Source code in chispa/six.py def exec_(_code_, _globs_=None, _locs_=None): \"\"\"Execute code in a namespace.\"\"\" if _globs_ is None: frame = sys._getframe(1) _globs_ = frame.f_globals if _locs_ is None: _locs_ = frame.f_locals del frame elif _locs_ is None: _locs_ = _globs_ exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\") python_2_unicode_compatible(klass) A class decorator that defines unicode and str methods under Python 2. Under Python 3 it does nothing. To support Python 2 and 3 with a single code base, define a str method returning text and apply this decorator to the class. Source code in chispa/six.py def python_2_unicode_compatible(klass): \"\"\" A class decorator that defines __unicode__ and __str__ methods under Python 2. Under Python 3 it does nothing. To support Python 2 and 3 with a single code base, define a __str__ method returning text and apply this decorator to the class. \"\"\" if PY2: if '__str__' not in klass.__dict__: raise ValueError(\"@python_2_unicode_compatible cannot be applied \" \"to %s because it doesn't define __str__().\" % klass.__name__) klass.__unicode__ = klass.__str__ klass.__str__ = lambda self: self.__unicode__().encode('utf-8') return klass remove_move(name) Remove item from six.moves. Source code in chispa/six.py def remove_move(name): \"\"\"Remove item from six.moves.\"\"\" try: delattr(_MovedItems, name) except AttributeError: try: del moves.__dict__[name] except KeyError: raise AttributeError(\"no such move, %r\" % (name,)) with_metaclass(meta, *bases) Create a base class with a metaclass. Source code in chispa/six.py def with_metaclass(meta, *bases): \"\"\"Create a base class with a metaclass.\"\"\" # This requires a bit of explanation: the basic idea is to make a dummy # metaclass for one level of class instantiation that replaces itself with # the actual metaclass. class metaclass(type): def __new__(cls, name, this_bases, d): if sys.version_info[:2] >= (3, 7): # This version introduced PEP 560 that requires a bit # of extra care (we mimic what is done by __build_class__). resolved_bases = types.resolve_bases(bases) if resolved_bases is not bases: d['__orig_bases__'] = bases else: resolved_bases = bases return meta(name, resolved_bases, d) @classmethod def __prepare__(cls, name, this_bases): return meta.__prepare__(name, bases) return type.__new__(metaclass, 'temporary_class', (), {})","title":"Six"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib","text":"Bases: types . ModuleType Create a six.moves.urllib namespace that resembles the Python 3 namespace Source code in chispa/six.py class Module_six_moves_urllib(types.ModuleType): \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\" __path__ = [] # mark as package parse = _importer._get_module(\"moves.urllib_parse\") error = _importer._get_module(\"moves.urllib_error\") request = _importer._get_module(\"moves.urllib_request\") response = _importer._get_module(\"moves.urllib_response\") robotparser = _importer._get_module(\"moves.urllib_robotparser\") def __dir__(self): return ['parse', 'error', 'request', 'response', 'robotparser']","title":"Module_six_moves_urllib"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib_error","text":"Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_error Source code in chispa/six.py class Module_six_moves_urllib_error(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"","title":"Module_six_moves_urllib_error"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib_parse","text":"Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_parse Source code in chispa/six.py class Module_six_moves_urllib_parse(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"","title":"Module_six_moves_urllib_parse"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib_request","text":"Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_request Source code in chispa/six.py class Module_six_moves_urllib_request(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"","title":"Module_six_moves_urllib_request"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib_response","text":"Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_response Source code in chispa/six.py class Module_six_moves_urllib_response(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"","title":"Module_six_moves_urllib_response"},{"location":"reference/chispa/six/#chispa.six.Module_six_moves_urllib_robotparser","text":"Bases: _LazyModule Lazy loading of moved objects in six.moves.urllib_robotparser Source code in chispa/six.py class Module_six_moves_urllib_robotparser(_LazyModule): \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"","title":"Module_six_moves_urllib_robotparser"},{"location":"reference/chispa/six/#chispa.six.add_metaclass","text":"Class decorator for creating a class with a metaclass. Source code in chispa/six.py def add_metaclass(metaclass): \"\"\"Class decorator for creating a class with a metaclass.\"\"\" def wrapper(cls): orig_vars = cls.__dict__.copy() slots = orig_vars.get('__slots__') if slots is not None: if isinstance(slots, str): slots = [slots] for slots_var in slots: orig_vars.pop(slots_var) orig_vars.pop('__dict__', None) orig_vars.pop('__weakref__', None) if hasattr(cls, '__qualname__'): orig_vars['__qualname__'] = cls.__qualname__ return metaclass(cls.__name__, cls.__bases__, orig_vars) return wrapper","title":"add_metaclass()"},{"location":"reference/chispa/six/#chispa.six.add_move","text":"Add an item to six.moves. Source code in chispa/six.py def add_move(move): \"\"\"Add an item to six.moves.\"\"\" setattr(_MovedItems, move.name, move)","title":"add_move()"},{"location":"reference/chispa/six/#chispa.six.ensure_binary","text":"Coerce s to six.binary_type. For Python 2: - unicode -> encoded to str - str -> str For Python 3: - str -> encoded to bytes - bytes -> bytes Source code in chispa/six.py def ensure_binary(s, encoding='utf-8', errors='strict'): \"\"\"Coerce **s** to six.binary_type. For Python 2: - `unicode` -> encoded to `str` - `str` -> `str` For Python 3: - `str` -> encoded to `bytes` - `bytes` -> `bytes` \"\"\" if isinstance(s, binary_type): return s if isinstance(s, text_type): return s.encode(encoding, errors) raise TypeError(\"not expecting type '%s'\" % type(s))","title":"ensure_binary()"},{"location":"reference/chispa/six/#chispa.six.ensure_str","text":"Coerce s to str . For Python 2: - unicode -> encoded to str - str -> str For Python 3: - str -> str - bytes -> decoded to str Source code in chispa/six.py def ensure_str(s, encoding='utf-8', errors='strict'): \"\"\"Coerce *s* to `str`. For Python 2: - `unicode` -> encoded to `str` - `str` -> `str` For Python 3: - `str` -> `str` - `bytes` -> decoded to `str` \"\"\" # Optimization: Fast return for the common case. if type(s) is str: return s if PY2 and isinstance(s, text_type): return s.encode(encoding, errors) elif PY3 and isinstance(s, binary_type): return s.decode(encoding, errors) elif not isinstance(s, (text_type, binary_type)): raise TypeError(\"not expecting type '%s'\" % type(s)) return s","title":"ensure_str()"},{"location":"reference/chispa/six/#chispa.six.ensure_text","text":"Coerce s to six.text_type. For Python 2: - unicode -> unicode - str -> unicode For Python 3: - str -> str - bytes -> decoded to str Source code in chispa/six.py def ensure_text(s, encoding='utf-8', errors='strict'): \"\"\"Coerce *s* to six.text_type. For Python 2: - `unicode` -> `unicode` - `str` -> `unicode` For Python 3: - `str` -> `str` - `bytes` -> decoded to `str` \"\"\" if isinstance(s, binary_type): return s.decode(encoding, errors) elif isinstance(s, text_type): return s else: raise TypeError(\"not expecting type '%s'\" % type(s))","title":"ensure_text()"},{"location":"reference/chispa/six/#chispa.six.exec_","text":"Execute code in a namespace. Source code in chispa/six.py def exec_(_code_, _globs_=None, _locs_=None): \"\"\"Execute code in a namespace.\"\"\" if _globs_ is None: frame = sys._getframe(1) _globs_ = frame.f_globals if _locs_ is None: _locs_ = frame.f_locals del frame elif _locs_ is None: _locs_ = _globs_ exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")","title":"exec_()"},{"location":"reference/chispa/six/#chispa.six.python_2_unicode_compatible","text":"A class decorator that defines unicode and str methods under Python 2. Under Python 3 it does nothing. To support Python 2 and 3 with a single code base, define a str method returning text and apply this decorator to the class. Source code in chispa/six.py def python_2_unicode_compatible(klass): \"\"\" A class decorator that defines __unicode__ and __str__ methods under Python 2. Under Python 3 it does nothing. To support Python 2 and 3 with a single code base, define a __str__ method returning text and apply this decorator to the class. \"\"\" if PY2: if '__str__' not in klass.__dict__: raise ValueError(\"@python_2_unicode_compatible cannot be applied \" \"to %s because it doesn't define __str__().\" % klass.__name__) klass.__unicode__ = klass.__str__ klass.__str__ = lambda self: self.__unicode__().encode('utf-8') return klass","title":"python_2_unicode_compatible()"},{"location":"reference/chispa/six/#chispa.six.remove_move","text":"Remove item from six.moves. Source code in chispa/six.py def remove_move(name): \"\"\"Remove item from six.moves.\"\"\" try: delattr(_MovedItems, name) except AttributeError: try: del moves.__dict__[name] except KeyError: raise AttributeError(\"no such move, %r\" % (name,))","title":"remove_move()"},{"location":"reference/chispa/six/#chispa.six.with_metaclass","text":"Create a base class with a metaclass. Source code in chispa/six.py def with_metaclass(meta, *bases): \"\"\"Create a base class with a metaclass.\"\"\" # This requires a bit of explanation: the basic idea is to make a dummy # metaclass for one level of class instantiation that replaces itself with # the actual metaclass. class metaclass(type): def __new__(cls, name, this_bases, d): if sys.version_info[:2] >= (3, 7): # This version introduced PEP 560 that requires a bit # of extra care (we mimic what is done by __build_class__). resolved_bases = types.resolve_bases(bases) if resolved_bases is not bases: d['__orig_bases__'] = bases else: resolved_bases = bases return meta(name, resolved_bases, d) @classmethod def __prepare__(cls, name, this_bases): return meta.__prepare__(name, bases) return type.__new__(metaclass, 'temporary_class', (), {})","title":"with_metaclass()"},{"location":"reference/chispa/structfield_comparer/","text":"","title":"Structfield comparer"},{"location":"reference/chispa/terminal_str_formatter/","text":"","title":"Terminal str formatter"}]}